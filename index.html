<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>MAZE // HUNGER — Vertical Slice</title>

  <style>
    :root{
      --bg:#06070b;
      --ink:#e8e9ff;
      --dim:#9aa0c8;
      --accent:#7df9ff;
      --danger:#ff5a7a;
      --good:#7CFF9A;
      --gold:#ffd36e;

      /* Layout tuning */
      --pad: 10px;
      --uiH: 42svh;            /* safer on iOS than vh */
      --uiMax: 430px;
      --uiMin: 230px;
    }

    html,body{
      margin:0;
      background:var(--bg);
      color:var(--ink);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      overflow:hidden;
      height:100%;
    }

    /* Use safe viewport where supported */
    body{
      height: 100svh;
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);
      box-sizing:border-box;
    }

    #wrap{
      height:100%;
      display:flex;
      flex-direction:column;
    }

    #gameArea{
      flex:1;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: var(--pad);
      box-sizing:border-box;
      min-height: 0; /* important for flex children on iOS */
    }

    canvas{
      width:100%;
      height:100%;
      background:#04040e;
      border-radius:16px;
      box-shadow: 0 16px 60px rgba(0,0,0,.55);
      touch-action:none;
      display:block;
    }

    #ui{
      height: min(var(--uiH), var(--uiMax));
      min-height: var(--uiMin);
      background:linear-gradient(180deg, rgba(11,13,27,.92), rgba(8,9,20,.98));
      border-top:1px solid rgba(125,249,255,.14);
      padding: 10px 12px calc(10px + env(safe-area-inset-bottom));
      box-sizing:border-box;

      display:grid;
      grid-template-columns: 1.15fr 1fr;
      grid-template-rows:auto 1fr;
      gap:10px;

      overflow:hidden; /* stop tiny overflow clipping issues */
    }

    #stats{
      grid-column:1 / span 2;
      display:grid;
      gap:8px;
      /* Auto-fit prevents clipping on narrow phones */
      grid-template-columns: repeat(auto-fit, minmax(112px, 1fr));
    }

    .card{
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.07);
      border-radius:12px;
      padding:10px;
      box-sizing:border-box;
      min-width:0;
    }

    .label{font-size:12px; color:var(--dim); letter-spacing:.02em;}
    .value{font-size:18px; margin-top:4px; font-weight:800;}
    .sub{font-size:12px; color:rgba(232,233,255,.72); margin-top:6px; line-height:1.25;}

    .bar{height:8px; background:rgba(255,255,255,.08); border-radius:999px; overflow:hidden; margin-top:8px;}
    .fill{height:100%; width:50%; background:var(--accent);}
    .fill.danger{background:var(--danger);}
    .fill.good{background:var(--good);}

    #controlsLeft, #controlsRight{
      display:flex;
      gap:10px;
      align-items:stretch;
      min-width:0;
    }

    .btn{
      display:flex; align-items:center; justify-content:center;
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      color:var(--ink);
      font-weight:800;
      letter-spacing:.02em;
      user-select:none;
      touch-action:none;
    }
    .btn:active, .btn.active{
      background:rgba(125,249,255,.14);
      border-color:rgba(125,249,255,.35);
      box-shadow: 0 0 0 2px rgba(125,249,255,.12) inset;
    }
    .btn.hot{
      background:rgba(255,211,110,.10);
      border-color:rgba(255,211,110,.30);
      box-shadow: 0 0 0 2px rgba(255,211,110,.10) inset;
    }
    .btn.disabled{
      opacity:.35;
      filter:saturate(.55);
      pointer-events:none;
    }

    /* D-pad */
    .dpad{
      width:min(38vw, 215px);
      max-width: 215px;
      aspect-ratio:1/1;
      display:grid;
      grid-template-columns:repeat(3,1fr);
      grid-template-rows:repeat(3,1fr);
      gap:8px;
    }
    .dpad .spacer{opacity:0; pointer-events:none;}

    /* Action buttons */
    .actions{
      display:flex;
      flex-direction:column;
      gap:10px;
      width:min(34vw, 200px);
      max-width: 200px;
      min-width: 0;
    }
    .bigBtn{flex:1; min-height:64px; font-size:16px;}
    .hint{font-size:12px; color:var(--dim); margin-top:6px; line-height:1.25;}
    .row{display:flex; gap:8px; align-items:center; justify-content:space-between;}

    #toast{
      position:absolute; left:12px; top:calc(12px + env(safe-area-inset-top));
      background:rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.10);
      padding:8px 10px; border-radius:10px;
      font-size:12px; color:var(--ink);
      opacity:0; transform:translateY(-6px);
      transition:.18s ease;
      pointer-events:none;
      backdrop-filter: blur(6px);
    }
    #toast.show{opacity:1; transform:translateY(0);}

    /* Modal */
    #modalBack{
      position:absolute; inset:0;
      background:rgba(0,0,0,.72);
      display:none;
      align-items:center;
      justify-content:center;
      padding:14px;
      box-sizing:border-box;
    }
    #modalBack.show{display:flex;}
    #modal{
      width:min(720px, 100%);
      background:rgba(11,13,27,.96);
      border:1px solid rgba(125,249,255,.16);
      border-radius:18px;
      box-shadow: 0 18px 70px rgba(0,0,0,.65);
      padding:16px 16px 14px;
      box-sizing:border-box;
    }
    #modal h1{margin:0 0 6px; font-size:22px; letter-spacing:.06em;}
    #modal .tag{color:rgba(232,233,255,.8); font-size:13px; margin-bottom:10px;}
    #modal .cols{display:grid; grid-template-columns: 1.2fr 1fr; gap:12px;}
    #modal .box{
      border:1px solid rgba(255,255,255,.08);
      background:rgba(255,255,255,.03);
      border-radius:14px;
      padding:12px;
    }
    #modal .box .t{font-weight:800; margin-bottom:6px;}
    #modal ul{margin:8px 0 0 18px; padding:0; color:rgba(232,233,255,.78); font-size:13px; line-height:1.3;}
    #modal .footer{display:flex; justify-content:space-between; align-items:center; gap:10px; margin-top:12px;}
    #modal .small{color:rgba(232,233,255,.65); font-size:12px; line-height:1.2;}
    #modal .start{
      padding:12px 14px;
      border-radius:14px;
      border:1px solid rgba(125,249,255,.35);
      background:rgba(125,249,255,.14);
      color:var(--ink);
      font-weight:900;
      letter-spacing:.05em;
      cursor:pointer;
    }
    #modal .menuBtn{
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.05);
      color:rgba(232,233,255,.85);
      font-weight:800;
      cursor:pointer;
    }

    /* Optional error overlay (only shows if something crashes) */
    #errBox{
      position:absolute; left:12px; right:12px; bottom:calc(12px + env(safe-area-inset-bottom));
      background:rgba(0,0,0,.78);
      border:1px solid rgba(255,90,122,.35);
      border-radius:12px;
      padding:10px;
      font-size:12px;
      color:rgba(255,215,221,.95);
      display:none;
      white-space:pre-wrap;
      max-height:42vh;
      overflow:auto;
      backdrop-filter: blur(6px);
      z-index: 99;
    }
    #errBox.show{display:block;}
  </style>
</head>

<body>
<div id="wrap">
  <div id="gameArea">
    <canvas id="c"></canvas>
  </div>

  <div id="ui">
    <div id="stats">
      <div class="card">
        <div class="label">Score</div>
        <div id="score" class="value">0</div>
        <div id="mult" class="sub">×1.0 (keep moving)</div>
      </div>
      <div class="card">
        <div class="label">Integrity</div>
        <div id="hp" class="value">100</div>
        <div class="bar"><div id="hpFill" class="fill good"></div></div>
      </div>
      <div class="card">
        <div class="label">Hunger</div>
        <div id="hunger" class="value">0</div>
        <div class="bar"><div id="hunFill" class="fill danger"></div></div>
      </div>
      <div class="card">
        <div class="label">Stage</div>
        <div id="stage" class="value">1</div>
        <div id="padHint" class="sub">Touch / Keys / Gamepad</div>
      </div>
      <div class="card">
        <div class="label">Exit</div>
        <div id="exitState" class="value">LOCKED</div>
        <div id="pelLeft" class="sub">pellets: —</div>
      </div>
    </div>

    <div id="controlsLeft" class="card">
      <div>
        <div class="label">D-Pad</div>
        <div class="dpad" id="dpad">
          <div class="spacer"></div>
          <div class="btn" data-dir="up">▲</div>
          <div class="spacer"></div>

          <div class="btn" data-dir="left">◀</div>
          <div class="btn" data-dir="none">●</div>
          <div class="btn" data-dir="right">▶</div>

          <div class="spacer"></div>
          <div class="btn" data-dir="down">▼</div>
          <div class="spacer"></div>
        </div>
        <div class="hint">Turn buffering: press early, turn at the next opening.</div>
      </div>
    </div>

    <div id="controlsRight" class="card">
      <div class="actions">
        <div class="label">Actions</div>
        <div id="btnPower" class="btn bigBtn">POWER</div>
        <div id="btnScan" class="btn bigBtn">SCAN</div>
        <div class="hint">
          POWER: speed burst (cooldown)<br/>
          SCAN: reveal pellets + sentinel briefly
        </div>
        <div class="row hint">
          <span>Menu:</span><span>Tap “●”</span>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="toast"></div>

<div id="modalBack">
  <div id="modal">
    <h1>MAZE // HUNGER</h1>
    <div class="tag">Consume. Evolve. Escape.</div>

    <div class="cols">
      <div class="box">
        <div class="t">HOW TO PLAY</div>
        <ul>
          <li>Eat <b>Glyphs</b> to score and reduce <b>Hunger</b>.</li>
          <li>Hunger rises constantly. At max, you take damage.</li>
          <li>Clear enough glyphs to unlock the <b>Exit</b>.</li>
          <li>Avoid the <b>Sentinel</b>. Contact damages Integrity.</li>
        </ul>
      </div>

      <div class="box">
        <div class="t">CONTROLS</div>
        <ul>
          <li><b>Touch</b>: D-pad + POWER + SCAN</li>
          <li><b>Keyboard</b>: Arrows + Space (POWER) + Shift (SCAN)</li>
          <li><b>Controller</b>: Stick/D-pad + A (POWER) + B (SCAN)</li>
        </ul>
        <div class="small" style="margin-top:10px;">
          Tip: press turns early—your intent stays buffered.
        </div>
      </div>
    </div>

    <div class="footer">
      <div style="display:flex; gap:10px; align-items:center;">
        <button id="btnResetRun" class="menuBtn">Reset Run</button>
        <button id="btnClose" class="menuBtn">Close</button>
      </div>
      <button id="btnStart" class="start">START RUN ▶</button>
    </div>
  </div>
</div>

<div id="errBox"></div>

<script>
(() => {
  // ---------------------------
  // Error overlay (only shows if something breaks)
  // ---------------------------
  const errBox = document.getElementById('errBox');
  function showError(msg){
    errBox.textContent = msg;
    errBox.classList.add('show');
  }
  window.addEventListener('error', (e)=>{
    showError(`JS ERROR:\n${e.message}\n\n${e.filename || ''}:${e.lineno || ''}:${e.colno || ''}\n\n${e.error?.stack || ''}`);
  });
  window.addEventListener('unhandledrejection', (e)=>{
    showError(`PROMISE REJECTION:\n${e.reason?.message || e.reason}\n\n${e.reason?.stack || ''}`);
  });

  // ---------------------------
  // Canvas + sizing
  // ---------------------------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });

  function resize() {
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
    canvas.width  = Math.max(1, Math.floor(rect.width * dpr));
    canvas.height = Math.max(1, Math.floor(rect.height * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  window.addEventListener('resize', () => requestAnimationFrame(resize), { passive:true });
  window.addEventListener('orientationchange', () => setTimeout(resize, 90), { passive:true });
  document.addEventListener('visibilitychange', () => { if(!document.hidden) setTimeout(resize, 90); });

  resize();

  // ---------------------------
  // UI elements
  // ---------------------------
  const uiScore = document.getElementById('score');
  const uiMult = document.getElementById('mult');
  const uiHP = document.getElementById('hp');
  const uiHPFill = document.getElementById('hpFill');
  const uiHunger = document.getElementById('hunger');
  const uiHunFill = document.getElementById('hunFill');
  const uiStage = document.getElementById('stage');
  const uiPadHint = document.getElementById('padHint');
  const uiExitState = document.getElementById('exitState');
  const uiPelLeft = document.getElementById('pelLeft');

  const btnPower = document.getElementById('btnPower');
  const btnScan  = document.getElementById('btnScan');

  const modalBack = document.getElementById('modalBack');
  const btnStart = document.getElementById('btnStart');
  const btnClose = document.getElementById('btnClose');
  const btnResetRun = document.getElementById('btnResetRun');

  const toast = document.getElementById('toast');
  function showToast(msg){
    toast.textContent = msg;
    toast.classList.add('show');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>toast.classList.remove('show'), 900);
  }

  // ---------------------------
  // Modal
  // ---------------------------
  let paused = false;
  let last = performance.now();

  function openModal(){
    modalBack.classList.add('show');
    paused = true;
    requestAnimationFrame(resize);
  }

  function closeModal(){
    modalBack.classList.remove('show');
    paused = false;
    requestAnimationFrame(() => {
      resize();
      last = performance.now();
      render(0);
    });
  }

  btnStart.addEventListener('click', ()=>{ closeModal(); requestAnimationFrame(resize); });
  btnClose.addEventListener('click', ()=>{ closeModal(); });
  btnResetRun.addEventListener('click', ()=>{ resetRun(); closeModal(); });

  const FIRST_KEY = 'maze_hunger_seen_rules_v2';
  if(!localStorage.getItem(FIRST_KEY)){
    openModal();
    localStorage.setItem(FIRST_KEY, '1');
  }

  // ---------------------------
  // Game constants
  // ---------------------------
  const CELL = 22;
  const MAZE_W = 25;
  const MAZE_H = 19;
  const WALL = 1, FLOOR = 0;

  // Turning feel knobs (this is the magic)
  const TURN_EPS = 0.18;          // how close to cell-center to allow a turn (bigger = more forgiving)
  const CENTER_PULL = 16.0;       // corridor auto-centering strength (higher = stronger)
  const EXIT_THRESHOLD_BASE = 30;
  const EXIT_THRESHOLD_STAGE_DECAY = 1;

  // ---------------------------
  // RNG
  // ---------------------------
  function mulberry32(seed){
    return function(){
      let t = seed += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }

  // ---------------------------
  // Maze gen
  // ---------------------------
  function key(x,y){ return (x<<16)|y; }
  function unkey(k){ return {x:(k>>>16)&0xffff, y:k&0xffff}; }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

  function genMaze(stage) {
    const seed = (Date.now() ^ (stage*99991)) >>> 0;
    const rand = mulberry32(seed);
    const w = MAZE_W, h = MAZE_H;
    const grid = Array.from({length:h}, ()=> Array(w).fill(WALL));

    function inb(x,y){ return x>=0 && y>=0 && x<w && y<h; }
    const dirs = [{dx:2,dy:0},{dx:-2,dy:0},{dx:0,dy:2},{dx:0,dy:-2}];

    grid[1][1] = FLOOR;
    const stack = [{x:1,y:1}];
    while(stack.length){
      const cur = stack[stack.length-1];
      const options = [];
      for(const d of dirs){
        const nx = cur.x+d.dx, ny=cur.y+d.dy;
        if(inb(nx,ny) && grid[ny][nx]===WALL) options.push(d);
      }
      if(!options.length){ stack.pop(); continue; }
      const d = options[(rand()*options.length)|0];
      const nx = cur.x+d.dx, ny=cur.y+d.dy;
      grid[cur.y + d.dy/2][cur.x + d.dx/2] = FLOOR;
      grid[ny][nx] = FLOOR;
      stack.push({x:nx,y:ny});
    }

    const loops = Math.min(55, 14 + stage*7);
    for(let i=0;i<loops;i++){
      const x = 1 + ((rand()*(w-2))|0);
      const y = 1 + ((rand()*(h-2))|0);
      if(grid[y][x]!==WALL) continue;
      const horiz = (grid[y][x-1]===FLOOR && grid[y][x+1]===FLOOR);
      const vert  = (grid[y-1][x]===FLOOR && grid[y+1][x]===FLOOR);
      if(horiz || vert) grid[y][x]=FLOOR;
    }

    const pellets = new Set();
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        if(grid[y][x]===FLOOR && !(x===1 && y===1)){
          const density = 0.90 - Math.min(0.18, stage*0.015);
          if(rand() < density) pellets.add(key(x,y));
        }
      }
    }

    let exit = {x:w-2,y:h-2};
    let best = -1;
    for(let tries=0;tries<260;tries++){
      const x = 1 + ((rand()*(w-2))|0);
      const y = 1 + ((rand()*(h-2))|0);
      if(grid[y][x]!==FLOOR) continue;
      const d = (x-1)*(x-1)+(y-1)*(y-1);
      if(d>best){best=d; exit={x,y};}
    }

    return { grid, pellets, exit };
  }

  // ---------------------------
  // Game state
  // ---------------------------
  const state = {
    stage: 1,
    score: 0,
    hp: 100,
    hunger: 0,
    multiplier: 1.0,
    multDecay: 0,

    scanTimer: 0,
    powerTimer: 0,
    powerCooldown: 0,
    scanCooldown: 0,

    hitFlash: 0,
    map: null,
    gameOver: false,
    exitReady: false,

    p: {
      x:1,y:1, px:1,py:1,
      dir:{x:1,y:0},
      want:{x:1,y:0},    // buffered forever until it becomes valid
      speed: 7.1,
      invuln: 0,
    },

    e: {
      x:MAZE_W-2,y:MAZE_H-2, px:MAZE_W-2,py:MAZE_H-2,
      speed: 5.6,
      stepAge: 0,
      dx:0,dy:0
    }
  };

  function isWall(x,y){
    const g = state.map.grid;
    if(y<0||y>=g.length||x<0||x>=g[0].length) return true;
    return g[y][x]===WALL;
  }
  function canMoveTo(x,y){ return !isWall(x,y); }

  function atCellCenter(px,py){
    const cx = Math.round(px), cy = Math.round(py);
    return (Math.abs(px-cx) < 0.10 && Math.abs(py-cy) < 0.10);
  }

  function nextStepToward(sx,sy,tx,ty){
    const w = MAZE_W, h = MAZE_H;
    const prev = new Int32Array(w*h).fill(-1);
    const q = [];
    const start = sy*w+sx, goal = ty*w+tx;
    q.push(start); prev[start]=start;

    while(q.length){
      const cur = q.shift();
      if(cur===goal) break;
      const cx = cur % w;
      const cy = (cur / w) | 0;

      const n1 = cur+1;
      if(cx+1<w && prev[n1]<0 && !isWall(cx+1,cy)){ prev[n1]=cur; q.push(n1); }
      const n2 = cur-1;
      if(cx-1>=0 && prev[n2]<0 && !isWall(cx-1,cy)){ prev[n2]=cur; q.push(n2); }
      const n3 = cur+w;
      if(cy+1<h && prev[n3]<0 && !isWall(cx,cy+1)){ prev[n3]=cur; q.push(n3); }
      const n4 = cur-w;
      if(cy-1>=0 && prev[n4]<0 && !isWall(cx,cy-1)){ prev[n4]=cur; q.push(n4); }
    }

    if(prev[goal]<0) return {x:sx,y:sy};
    let cur = goal;
    let p = prev[cur];
    while(p !== start && p !== cur){
      cur = p; p = prev[cur];
    }
    return {x:cur%w, y:(cur/w)|0};
  }

  function resetStage(){
    state.map = genMaze(state.stage);

    state.p.x = state.p.px = 1;
    state.p.y = state.p.py = 1;
    state.p.dir = {x:1,y:0};
    state.p.want = {x:1,y:0};

    state.e.x = state.e.px = state.map.exit.x;
    state.e.y = state.e.py = state.map.exit.y;
    state.e.dx = 0; state.e.dy = 0;
    state.e.stepAge = 0;

    state.scanTimer = 0;
    state.powerTimer = 0;
    state.powerCooldown = 0;
    state.scanCooldown = 0;
    state.exitReady = false;

    showToast(`Stage ${state.stage}`);
  }

  function resetRun(){
    state.stage = 1;
    state.score = 0;
    state.hp = 100;
    state.hunger = 0;
    state.multiplier = 1.0;
    state.multDecay = 0;
    state.gameOver = false;
    state.hitFlash = 0;
    resetStage();
    showToast('New Run');
  }

  resetStage();

  // ---------------------------
  // Input
  // ---------------------------
  const input = {
    up:false, down:false, left:false, right:false,
    power:false, scan:false
  };

  function setWanted(dir){
    state.p.want = dir; // buffered indefinitely
  }

  function setWantedFromInput(){
    // last pressed wins (classic arcade feel)
    if(input.left)  setWanted({x:-1,y:0});
    if(input.right) setWanted({x: 1,y:0});
    if(input.up)    setWanted({x: 0,y:-1});
    if(input.down)  setWanted({x: 0,y: 1});
  }

  const dpad = document.getElementById('dpad');
  const dpadButtons = [...dpad.querySelectorAll('.btn[data-dir]')];

  function activateDir(dir, on){
    // allow holding a single direction on touch
    input.up = input.down = input.left = input.right = false;
    if(on){
      if(dir==='up') input.up = true;
      if(dir==='down') input.down = true;
      if(dir==='left') input.left = true;
      if(dir==='right') input.right = true;
    }
    dpadButtons.forEach(b => b.classList.toggle('active', on && b.dataset.dir===dir));
    setWantedFromInput();
  }

  function bindPress(el, onDown, onUp){
    const down = (e)=>{ e.preventDefault(); onDown(); };
    const up = (e)=>{ e.preventDefault(); onUp(); };
    el.addEventListener('pointerdown', down);
    el.addEventListener('pointerup', up);
    el.addEventListener('pointercancel', up);
    el.addEventListener('pointerleave', up);
  }

  dpadButtons.forEach(btn=>{
    const dir = btn.dataset.dir;
    if(dir === 'none'){
      bindPress(btn, ()=>openModal(), ()=>{});
      return;
    }
    bindPress(btn, ()=>activateDir(dir,true), ()=>activateDir(dir,false));
  });

  bindPress(btnPower, ()=>{ input.power=true; }, ()=>{ input.power=false; });
  bindPress(btnScan,  ()=>{ input.scan=true;  }, ()=>{ input.scan=false;  });

  window.addEventListener('keydown', (e)=>{
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' ','Shift','Escape'].includes(e.key)) e.preventDefault();
    if(e.key==='Escape'){ openModal(); return; }
    if(paused) return;

    if(e.key==='ArrowUp') input.up = true;
    if(e.key==='ArrowDown') input.down = true;
    if(e.key==='ArrowLeft') input.left = true;
    if(e.key==='ArrowRight') input.right = true;
    if(e.key===' ') input.power = true;
    if(e.key==='Shift') input.scan = true;
    setWantedFromInput();
  }, {passive:false});

  window.addEventListener('keyup', (e)=>{
    if(paused) return;

    if(e.key==='ArrowUp') input.up = false;
    if(e.key==='ArrowDown') input.down = false;
    if(e.key==='ArrowLeft') input.left = false;
    if(e.key==='ArrowRight') input.right = false;
    if(e.key===' ') input.power = false;
    if(e.key==='Shift') input.scan = false;
    setWantedFromInput();
  });

  let lastPadConnected = false;
  window.addEventListener('gamepadconnected', ()=>{
    lastPadConnected = true;
    uiPadHint.textContent = 'Gamepad connected';
    showToast('Gamepad connected');
  });
  window.addEventListener('gamepaddisconnected', ()=>{
    uiPadHint.textContent = 'Touch / Keys / Gamepad';
    showToast('Gamepad disconnected');
  });

  function pollGamepad(){
    const pads = navigator.getGamepads ? navigator.getGamepads() : [];
    const gp = pads && pads[0];
    if(!gp) return;

    if(!lastPadConnected){
      lastPadConnected = true;
      uiPadHint.textContent = 'Gamepad active';
      showToast('Gamepad active');
    }

    const dead = 0.35;
    const axX = gp.axes[0] || 0;
    const axY = gp.axes[1] || 0;

    const dUp = gp.buttons[12]?.pressed;
    const dDown = gp.buttons[13]?.pressed;
    const dLeft = gp.buttons[14]?.pressed;
    const dRight = gp.buttons[15]?.pressed;

    input.up = (axY < -dead) || !!dUp;
    input.down = (axY > dead) || !!dDown;
    input.left = (axX < -dead) || !!dLeft;
    input.right = (axX > dead) || !!dRight;

    input.power = !!gp.buttons[0]?.pressed;
    input.scan  = !!gp.buttons[1]?.pressed;

    if(gp.buttons[9]?.pressed){ openModal(); }

    if(!paused) setWantedFromInput();
  }

  // ---------------------------
  // Actions
  // ---------------------------
  function tryPower(){
    if(state.powerCooldown>0 || state.powerTimer>0) return;
    state.powerTimer = 0.85;
    state.powerCooldown = 2.2;
    showToast('POWER');
  }
  function tryScan(){
    if(state.scanCooldown>0 || state.scanTimer>0) return;
    state.scanTimer = 1.15;
    state.scanCooldown = 3.0;
    showToast('SCAN');
  }

  // ---------------------------
  // Turning helpers (THE FIX)
  // ---------------------------
  function isPerpendicular(a,b){
    return (a.x !== 0 && b.y !== 0) || (a.y !== 0 && b.x !== 0);
  }

  // Try to apply buffered turn if we're close enough to a cell-center where it's legal.
  function tryApplyBufferedTurn(p){
    const want = p.want;
    if(!want || (want.x===0 && want.y===0)) return;

    const cx = Math.round(p.px);
    const cy = Math.round(p.py);

    const nearX = Math.abs(p.px - cx) <= TURN_EPS;
    const nearY = Math.abs(p.py - cy) <= TURN_EPS;

    // if stopped, any direction can start immediately from center-ish
    if(p.dir.x===0 && p.dir.y===0){
      if(nearX && nearY && canMoveTo(cx + want.x, cy + want.y)){
        p.px = cx; p.py = cy;
        p.x = cx;  p.y = cy;
        p.dir = {x: want.x, y: want.y};
      }
      return;
    }

    // If moving horizontally, allow vertical turn when we're centered vertically (nearY),
    // and at/near an intersection center (nearX) (for crisp turns).
    if(p.dir.x !== 0 && isPerpendicular(p.dir, want)){
      if(nearY && nearX && canMoveTo(cx + want.x, cy + want.y)){
        p.px = cx; p.py = cy;
        p.x = cx;  p.y = cy;
        p.dir = {x: want.x, y: want.y};
      }
      return;
    }

    // If moving vertically, allow horizontal turn when we're centered horizontally.
    if(p.dir.y !== 0 && isPerpendicular(p.dir, want)){
      if(nearX && nearY && canMoveTo(cx + want.x, cy + want.y)){
        p.px = cx; p.py = cy;
        p.x = cx;  p.y = cy;
        p.dir = {x: want.x, y: want.y};
      }
      return;
    }

    // If player presses reverse direction, allow immediate reversal if legal (nice feel).
    if((want.x === -p.dir.x && want.y === -p.dir.y) && nearX && nearY){
      if(canMoveTo(cx + want.x, cy + want.y)){
        p.px = cx; p.py = cy;
        p.x = cx;  p.y = cy;
        p.dir = {x: want.x, y: want.y};
      }
    }
  }

  // Corridor auto-centering: gently pulls you onto the gridline so turns don't “miss”.
  function applyAutoCenter(p, dt){
    const cx = Math.round(p.px);
    const cy = Math.round(p.py);

    if(p.dir.x !== 0){
      // moving horizontally: pull Y toward center
      const dy = (cy - p.py);
      p.py += dy * (1 - Math.exp(-CENTER_PULL * dt));
    } else if(p.dir.y !== 0){
      // moving vertically: pull X toward center
      const dx = (cx - p.px);
      p.px += dx * (1 - Math.exp(-CENTER_PULL * dt));
    }
  }

  // ---------------------------
  // Loop
  // ---------------------------
  canvas.addEventListener('pointerdown', ()=>{
    if(state.gameOver){
      resetRun();
      requestAnimationFrame(()=>{ resize(); render(0); });
    }
  });

  function tick(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    pollGamepad();

    if(paused || state.gameOver){
      render(dt);
      return;
    }

    // timers
    state.p.invuln = Math.max(0, state.p.invuln - dt);
    state.scanTimer = Math.max(0, state.scanTimer - dt);
    state.powerTimer = Math.max(0, state.powerTimer - dt);
    state.powerCooldown = Math.max(0, state.powerCooldown - dt);
    state.scanCooldown = Math.max(0, state.scanCooldown - dt);
    state.hitFlash = Math.max(0, state.hitFlash - dt*1.8);

    if(input.power) tryPower();
    if(input.scan) tryScan();

    btnPower.classList.toggle('active', state.powerTimer>0);
    btnPower.classList.toggle('disabled', state.powerCooldown>0 && state.powerTimer<=0);
    btnScan.classList.toggle('active', state.scanTimer>0);
    btnScan.classList.toggle('disabled', state.scanCooldown>0 && state.scanTimer<=0);
    btnPower.classList.toggle('hot', state.powerCooldown<=0 && state.powerTimer<=0);
    btnScan.classList.toggle('hot', state.scanCooldown<=0 && state.scanTimer<=0);

    // hunger + multiplier
    const movingInput = (input.up||input.down||input.left||input.right) || (state.p.dir.x!==0||state.p.dir.y!==0);

    state.hunger += dt * (movingInput ? 5.0 : 8.5);
    state.hunger = clamp(state.hunger, 0, 100);

    if(state.hunger >= 100){
      state.hp -= dt * 11.0;
      state.hitFlash = Math.max(state.hitFlash, 0.25);
    }

    if(movingInput){
      state.multiplier += dt * 0.18;
      state.multiplier = clamp(state.multiplier, 1.0, 6.0);
      state.multDecay = 0;
    } else {
      state.multDecay += dt;
      if(state.multDecay > 0.35){
        state.multiplier -= dt * 0.42;
        state.multiplier = clamp(state.multiplier, 1.0, 6.0);
      }
    }

    // PLAYER MOVEMENT (with buffered turns + centering)
    const p = state.p;

    // Apply auto-centering continuously for “sticky” corridors
    applyAutoCenter(p, dt);

    // Try buffered turn EVERY FRAME so you can press early
    tryApplyBufferedTurn(p);

    // Update cell lock + pellet eating when near center
    if(atCellCenter(p.px, p.py)){
      const cx = Math.round(p.px);
      const cy = Math.round(p.py);
      p.x = cx; p.y = cy;
      p.px = cx; p.py = cy;

      // If we're blocked ahead, stop (but keep buffered intent)
      if(!canMoveTo(cx+p.dir.x, cy+p.dir.y)){
        p.dir = {x:0,y:0};
      }

      const k = key(p.x,p.y);
      if(state.map.pellets.has(k)){
        state.map.pellets.delete(k);
        state.score += Math.round(10 * state.multiplier);
        state.hunger = clamp(state.hunger - 14, 0, 100);
        if(state.hunger > 70) state.hp = clamp(state.hp + 0.6, 0, 100);
      }
    }

    const baseSpeed = p.speed + (state.hunger/100)*1.05;
    const spd = baseSpeed * (state.powerTimer>0 ? 1.65 : 1.0);

    if(p.dir.x!==0 || p.dir.y!==0){
      const nx = p.px + p.dir.x * spd * dt;
      const ny = p.py + p.dir.y * spd * dt;

      const cx = Math.round(p.px);
      const cy = Math.round(p.py);

      if(p.dir.x!==0){
        const nextCellX = p.dir.x>0 ? cx+1 : cx-1;
        const boundary = cx + (p.dir.x>0 ? 0.5 : -0.5);
        if(!canMoveTo(nextCellX, cy) && ((p.dir.x>0 && nx>boundary) || (p.dir.x<0 && nx<boundary))){
          p.px = cx; p.py = cy;
          p.dir = {x:0,y:0};
        } else {
          p.px = nx; p.py = ny;
        }
      } else {
        const nextCellY = p.dir.y>0 ? cy+1 : cy-1;
        const boundary = cy + (p.dir.y>0 ? 0.5 : -0.5);
        if(!canMoveTo(cx, nextCellY) && ((p.dir.y>0 && ny>boundary) || (p.dir.y<0 && ny<boundary))){
          p.px = cx; p.py = cy;
          p.dir = {x:0,y:0};
        } else {
          p.px = nx; p.py = ny;
        }
      }
    }

    // Exit condition
    const pelletsLeft = state.map.pellets.size;
    const threshold = Math.max(0, EXIT_THRESHOLD_BASE - (state.stage*EXIT_THRESHOLD_STAGE_DECAY));
    state.exitReady = pelletsLeft <= threshold;

    const exit = state.map.exit;
    const onExit = (p.x===exit.x && p.y===exit.y);
    if(onExit && state.exitReady){
      state.stage++;
      state.score += Math.round(75 * state.multiplier);
      resetStage();
    }

    // ENEMY
    const e = state.e;
    const eSpeed = e.speed * (state.scanTimer>0 ? 0.88 : 1.0);

    e.stepAge += dt;
    if(atCellCenter(e.px,e.py) || e.stepAge > 0.26){
      e.stepAge = 0;
      e.x = Math.round(e.px); e.y = Math.round(e.py);
      e.px = e.x; e.py = e.y;

      const step = nextStepToward(e.x,e.y, p.x,p.y);
      e.dx = clamp(step.x - e.x, -1, 1);
      e.dy = clamp(step.y - e.y, -1, 1);
    }

    if(e.dx || e.dy){
      e.px += e.dx * eSpeed * dt;
      e.py += e.dy * eSpeed * dt;
    }

    const dist = Math.hypot((p.px - e.px), (p.py - e.py));
    if(dist < 0.40 && p.invuln<=0){
      state.hp -= 19;
      state.p.invuln = 0.85;
      state.multiplier = 1.0;
      state.hitFlash = 1.0;
      showToast('HIT!');
    }

    state.hp = clamp(state.hp, 0, 100);
    if(state.hp<=0){
      state.gameOver = true;
      showToast('SYSTEM FAILURE — Tap to restart');
    }

    // UI
    uiScore.textContent = String(state.score);
    uiMult.textContent = `×${state.multiplier.toFixed(1)} (${movingInput ? 'rolling' : 'decay'})`;

    uiHP.textContent = String(Math.round(state.hp));
    uiHunger.textContent = String(Math.round(state.hunger));
    uiStage.textContent = String(state.stage);

    uiHPFill.style.width = `${state.hp}%`;
    uiHPFill.classList.toggle('danger', state.hp<35);
    uiHPFill.classList.toggle('good', state.hp>=35);

    uiHunFill.style.width = `${state.hunger}%`;

    uiExitState.textContent = state.exitReady ? 'READY' : 'LOCKED';
    uiExitState.style.color = state.exitReady ? 'var(--good)' : 'var(--ink)';
    uiPelLeft.textContent = `pellets: ${pelletsLeft} (need ≤ ${threshold})`;

    render(dt);
  }

  // ---------------------------
  // Render
  // ---------------------------
  function render(dt){
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;

    const mazePxW = MAZE_W * CELL;
    const mazePxH = MAZE_H * CELL;
    const scale = Math.min((w-18)/mazePxW, (h-18)/mazePxH);
    const drawW = mazePxW * scale;
    const drawH = mazePxH * scale;
    const ox = (w - drawW)/2;
    const oy = (h - drawH)/2;

    ctx.fillStyle = '#04040e';
    ctx.fillRect(0,0,w,h);

    if(state.hitFlash>0){
      ctx.fillStyle = `rgba(255,90,122,${0.18*state.hitFlash})`;
      ctx.fillRect(0,0,w,h);
    }

    ctx.save();
    ctx.translate(ox, oy);
    ctx.scale(scale, scale);

    const scan = state.scanTimer>0;

    ctx.shadowBlur = 10;
    ctx.shadowColor = 'rgba(125,249,255,0.35)';

    for(let y=0; y<MAZE_H; y++){
      for(let x=0; x<MAZE_W; x++){
        if(state.map.grid[y][x]===WALL){
          ctx.fillStyle = 'rgba(125,249,255,0.11)';
          ctx.fillRect(x*CELL, y*CELL, CELL, CELL);
        } else {
          ctx.fillStyle = 'rgba(255,255,255,0.02)';
          ctx.fillRect(x*CELL, y*CELL, CELL, CELL);
        }
      }
    }

    ctx.shadowBlur = scan ? 14 : 8;
    ctx.shadowColor = scan ? 'rgba(125,249,255,0.55)' : 'rgba(232,233,255,0.25)';
    for(const k of state.map.pellets){
      const {x,y} = unkey(k);
      const cx = x*CELL + CELL*0.5;
      const cy = y*CELL + CELL*0.5;
      ctx.beginPath();
      ctx.arc(cx, cy, scan ? 4.6 : 3.2, 0, Math.PI*2);
      ctx.fillStyle = scan ? 'rgba(125,249,255,0.95)' : 'rgba(232,233,255,0.70)';
      ctx.fill();
    }

    const ex = state.map.exit.x*CELL;
    const ey = state.map.exit.y*CELL;
    ctx.shadowBlur = 16;
    ctx.shadowColor = state.exitReady ? 'rgba(124,255,154,0.55)' : 'rgba(255,211,110,0.22)';
    ctx.fillStyle = state.exitReady ? 'rgba(124,255,154,0.14)' : 'rgba(255,211,110,0.06)';
    ctx.fillRect(ex+2, ey+2, CELL-4, CELL-4);
    ctx.strokeStyle = state.exitReady ? 'rgba(124,255,154,0.75)' : 'rgba(255,211,110,0.35)';
    ctx.lineWidth = 2;
    ctx.strokeRect(ex+4, ey+4, CELL-8, CELL-8);

    const e = state.e;
    const ecx = e.px*CELL + CELL*0.5;
    const ecy = e.py*CELL + CELL*0.5;
    ctx.shadowBlur = scan ? 18 : 14;
    ctx.shadowColor = 'rgba(255,90,122,0.55)';
    ctx.beginPath();
    ctx.arc(ecx, ecy, CELL*0.34, 0, Math.PI*2);
    ctx.fillStyle = scan ? 'rgba(255,90,122,0.95)' : 'rgba(255,90,122,0.83)';
    ctx.fill();

    const p = state.p;
    const pcx = p.px*CELL + CELL*0.5;
    const pcy = p.py*CELL + CELL*0.5;
    const mouth = 0.55 + 0.25*Math.sin(performance.now()/85);
    const ang = Math.atan2(p.dir.y, p.dir.x);
    ctx.shadowBlur = 16;
    ctx.shadowColor = (p.invuln>0) ? 'rgba(125,249,255,0.6)' : 'rgba(232,233,255,0.35)';
    ctx.beginPath();
    ctx.moveTo(pcx, pcy);
    ctx.arc(pcx, pcy, CELL*0.36, ang+mouth, ang+(Math.PI*2-mouth));
    ctx.closePath();
    ctx.fillStyle = (p.invuln>0) ? 'rgba(125,249,255,0.95)' : 'rgba(232,233,255,0.90)';
    ctx.fill();

    if(state.powerTimer>0){
      ctx.shadowBlur = 22;
      ctx.shadowColor = 'rgba(125,249,255,0.6)';
      ctx.beginPath();
      ctx.arc(pcx, pcy, CELL*0.58, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(125,249,255,0.65)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    if(paused){
      ctx.shadowBlur = 0;
      ctx.fillStyle = 'rgba(0,0,0,0.62)';
      ctx.fillRect(0,0,MAZE_W*CELL,MAZE_H*CELL);
      ctx.fillStyle = 'rgba(232,233,255,0.92)';
      ctx.font = 'bold 22px system-ui';
      ctx.textAlign='center';
      ctx.fillText('PAUSED', (MAZE_W*CELL)/2, (MAZE_H*CELL)/2);
      ctx.font = '13px system-ui';
      ctx.fillStyle = 'rgba(232,233,255,0.68)';
      ctx.fillText('Close the menu to resume', (MAZE_W*CELL)/2, (MAZE_H*CELL)/2 + 18);
    }

    if(state.gameOver){
      ctx.shadowBlur = 0;
      ctx.fillStyle = 'rgba(0,0,0,0.70)';
      ctx.fillRect(0,0,MAZE_W*CELL,MAZE_H*CELL);
      ctx.fillStyle = 'rgba(232,233,255,0.96)';
      ctx.font = 'bold 26px system-ui';
      ctx.textAlign='center';
      ctx.fillText('SYSTEM FAILURE', (MAZE_W*CELL)/2, (MAZE_H*CELL)/2 - 12);
      ctx.font = '14px system-ui';
      ctx.fillStyle = 'rgba(232,233,255,0.75)';
      ctx.fillText('Tap to restart', (MAZE_W*CELL)/2, (MAZE_H*CELL)/2 + 18);
    }

    ctx.restore();
  }

  // Safe loop (won’t silently die)
  function loop(now){
    try{
      tick(now);
    }catch(e){
      showError(`RUNTIME CRASH:\n${e.message}\n\n${e.stack || ''}`);
      return;
    }
    requestAnimationFrame(loop);
  }

  render(0);
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
