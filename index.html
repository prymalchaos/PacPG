<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>MAZE // HUNGER — Vertical Slice</title>

  <style>
    :root{
      --bg:#06070b;
      --ink:#e8e9ff;
      --dim:#9aa0c8;
      --accent:#7df9ff;
      --danger:#ff5a7a;
      --good:#7CFF9A;
      --gold:#ffd36e;

      --pad: 10px;
      --uiH: 42svh;
      --uiMax: 430px;
      --uiMin: 230px;
    }

    html,body{
      margin:0;
      background:var(--bg);
      color:var(--ink);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      overflow:hidden;
      height:100%;
    }

    body{
      height: 100svh;
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);
      box-sizing:border-box;
    }

    #wrap{height:100%; display:flex; flex-direction:column;}

    #gameArea{
      flex:1;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: var(--pad);
      box-sizing:border-box;
      min-height:0;
    }

    canvas{
      width:100%;
      height:100%;
      background:#04040e;
      border-radius:16px;
      box-shadow: 0 16px 60px rgba(0,0,0,.55);
      touch-action:none;
      display:block;
    }

    #ui{
      height: min(var(--uiH), var(--uiMax));
      min-height: var(--uiMin);
      background:linear-gradient(180deg, rgba(11,13,27,.92), rgba(8,9,20,.98));
      border-top:1px solid rgba(125,249,255,.14);
      padding: 10px 12px calc(10px + env(safe-area-inset-bottom));
      box-sizing:border-box;

      display:grid;
      grid-template-columns: 1.15fr 1fr;
      grid-template-rows:auto 1fr;
      gap:10px;

      overflow:hidden;
    }

    #stats{
      grid-column:1 / span 2;
      display:grid;
      gap:8px;
      grid-template-columns: repeat(auto-fit, minmax(112px, 1fr));
    }

    .card{
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.07);
      border-radius:12px;
      padding:10px;
      box-sizing:border-box;
      min-width:0;
    }

    .label{font-size:12px; color:var(--dim); letter-spacing:.02em;}
    .value{font-size:18px; margin-top:4px; font-weight:800;}
    .sub{font-size:12px; color:rgba(232,233,255,.72); margin-top:6px; line-height:1.25;}

    .bar{height:8px; background:rgba(255,255,255,.08); border-radius:999px; overflow:hidden; margin-top:8px;}
    .fill{height:100%; width:50%; background:var(--accent);}
    .fill.danger{background:var(--danger);}
    .fill.good{background:var(--good);}
    .fill.gold{background:var(--gold);}

    #controlsLeft, #controlsRight{
      display:flex;
      gap:10px;
      align-items:stretch;
      min-width:0;
    }

    .btn{
      display:flex; align-items:center; justify-content:center;
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      color:var(--ink);
      font-weight:800;
      letter-spacing:.02em;
      user-select:none;
      touch-action:none;
    }
    .btn:active, .btn.active{
      background:rgba(125,249,255,.14);
      border-color:rgba(125,249,255,.35);
      box-shadow: 0 0 0 2px rgba(125,249,255,.12) inset;
    }
    .btn.hot{
      background:rgba(255,211,110,.10);
      border-color:rgba(255,211,110,.30);
      box-shadow: 0 0 0 2px rgba(255,211,110,.10) inset;
    }
    .btn.disabled{
      opacity:.35;
      filter:saturate(.55);
      pointer-events:none;
    }

    .actions{
      display:flex;
      flex-direction:column;
      gap:10px;
      width:min(34vw, 200px);
      max-width: 200px;
      min-width: 0;
    }
    .bigBtn{flex:1; min-height:64px; font-size:16px;}
    .hint{font-size:12px; color:var(--dim); margin-top:6px; line-height:1.25;}
    .row{display:flex; gap:8px; align-items:center; justify-content:space-between;}

    #toast{
      position:absolute; left:12px; top:calc(12px + env(safe-area-inset-top));
      background:rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.10);
      padding:8px 10px; border-radius:10px;
      font-size:12px; color:var(--ink);
      opacity:0; transform:translateY(-6px);
      transition:.18s ease;
      pointer-events:none;
      backdrop-filter: blur(6px);
      z-index: 50;
    }
    #toast.show{opacity:1; transform:translateY(0);}

    /* Virtual joystick */
    #joyWrap{
      display:flex;
      flex-direction:column;
      gap:8px;
      width:min(42vw, 240px);
      max-width:240px;
      min-width:0;
    }
    #joy{
      position:relative;
      width: min(40vw, 220px);
      max-width:220px;
      aspect-ratio:1/1;
      border-radius:999px;
      background:rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.10);
      box-shadow: inset 0 0 0 2px rgba(125,249,255,.05);
      touch-action:none;
      overflow:hidden;
    }
    #joyBase{
      position:absolute;
      inset:16%;
      border-radius:999px;
      border:1px dashed rgba(255,255,255,.16);
      background:rgba(0,0,0,.10);
    }
    #joyKnob{
      position:absolute;
      width:34%;
      height:34%;
      left:50%;
      top:50%;
      transform: translate(-50%,-50%);
      border-radius:999px;
      background:rgba(125,249,255,.12);
      border:1px solid rgba(125,249,255,.35);
      box-shadow: 0 10px 30px rgba(0,0,0,.45);
    }
    #joyRow{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
    }
    #menuBtn{
      padding:10px 12px;
      border-radius:12px;
      font-weight:900;
      letter-spacing:.05em;
      min-width: 92px;
    }

    /* Modal */
    #modalBack{
      position:absolute; inset:0;
      background:rgba(0,0,0,.72);
      display:none;
      align-items:center;
      justify-content:center;
      padding:14px;
      box-sizing:border-box;
      z-index: 60;
    }
    #modalBack.show{display:flex;}
    #modal{
      width:min(720px, 100%);
      background:rgba(11,13,27,.96);
      border:1px solid rgba(125,249,255,.16);
      border-radius:18px;
      box-shadow: 0 18px 70px rgba(0,0,0,.65);
      padding:16px 16px 14px;
      box-sizing:border-box;
    }
    #modal h1{margin:0 0 6px; font-size:22px; letter-spacing:.06em;}
    #modal .tag{color:rgba(232,233,255,.8); font-size:13px; margin-bottom:10px;}
    #modal .cols{display:grid; grid-template-columns: 1.2fr 1fr; gap:12px;}
    #modal .box{
      border:1px solid rgba(255,255,255,.08);
      background:rgba(255,255,255,.03);
      border-radius:14px;
      padding:12px;
    }
    #modal .box .t{font-weight:800; margin-bottom:6px;}
    #modal ul{margin:8px 0 0 18px; padding:0; color:rgba(232,233,255,.78); font-size:13px; line-height:1.3;}
    #modal .footer{display:flex; justify-content:space-between; align-items:center; gap:10px; margin-top:12px;}
    #modal .small{color:rgba(232,233,255,.65); font-size:12px; line-height:1.2;}
    #modal .start{
      padding:12px 14px;
      border-radius:14px;
      border:1px solid rgba(125,249,255,.35);
      background:rgba(125,249,255,.14);
      color:var(--ink);
      font-weight:900;
      letter-spacing:.05em;
      cursor:pointer;
    }
    #modal .menuBtn{
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.05);
      color:rgba(232,233,255,.85);
      font-weight:800;
      cursor:pointer;
    }

    /* Error overlay (only if something crashes) */
    #errBox{
      position:absolute; left:12px; right:12px; bottom:calc(12px + env(safe-area-inset-bottom));
      background:rgba(0,0,0,.78);
      border:1px solid rgba(255,90,122,.35);
      border-radius:12px;
      padding:10px;
      font-size:12px;
      color:rgba(255,215,221,.95);
      display:none;
      white-space:pre-wrap;
      max-height:42vh;
      overflow:auto;
      backdrop-filter: blur(6px);
      z-index: 99;
    }
    #errBox.show{display:block;}
  </style>
</head>

<body>
<div id="wrap">
  <div id="gameArea">
    <canvas id="c"></canvas>
  </div>

  <div id="ui">
    <div id="stats">
      <div class="card">
        <div class="label">Score</div>
        <div id="score" class="value">0</div>
        <div id="mult" class="sub">×1.0 (keep moving)</div>
      </div>
      <div class="card">
        <div class="label">Integrity</div>
        <div id="hp" class="value">100</div>
        <div class="bar"><div id="hpFill" class="fill good"></div></div>
      </div>
      <div class="card">
        <div class="label">Hunger</div>
        <div id="hunger" class="value">0</div>
        <div class="bar"><div id="hunFill" class="fill danger"></div></div>
      </div>
      <div class="card">
        <div class="label">Fury</div>
        <div id="fury" class="value">0</div>
        <div class="bar"><div id="furFill" class="fill gold"></div></div>
      </div>
      <div class="card">
        <div class="label">Stage</div>
        <div id="stage" class="value">1</div>
        <div id="padHint" class="sub">Touch / Keys / Gamepad</div>
      </div>
      <div class="card">
        <div class="label">Exit</div>
        <div id="exitState" class="value">LOCKED</div>
        <div id="pelLeft" class="sub">pellets: —</div>
      </div>
    </div>

    <div id="controlsLeft" class="card">
      <div id="joyWrap">
        <div class="label">Thumbstick</div>
        <div id="joy">
          <div id="joyBase"></div>
          <div id="joyKnob"></div>
        </div>
        <div id="joyRow">
          <div class="hint" style="margin:0;">4-way snap. Press early to auto-turn.</div>
          <div id="menuBtn" class="btn">MENU</div>
        </div>
      </div>
    </div>

    <div id="controlsRight" class="card">
      <div class="actions">
        <div class="label">Actions</div>
        <div id="btnPower" class="btn bigBtn">POWER</div>
        <div id="btnAttack" class="btn bigBtn">ATTACK</div>
        <div class="hint">
          POWER: speed burst (cooldown)<br/>
          ATTACK: spend Fury to strike (kill → full heal)
        </div>
        <div class="row hint">
          <span>Gamepad:</span><span>A=POWER, B=ATTACK</span>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="toast"></div>

<div id="modalBack">
  <div id="modal">
    <h1>MAZE // HUNGER</h1>
    <div class="tag">Consume. Evolve. Escape.</div>

    <div class="cols">
      <div class="box">
        <div class="t">HOW TO PLAY</div>
        <ul>
          <li>Eat <b>Glyphs</b> to score, reduce <b>Hunger</b>, gain <b>Fury</b>.</li>
          <li>Hunger rises constantly. At max, you take damage.</li>
          <li>Clear enough glyphs to unlock the <b>Exit</b>.</li>
          <li><b>Sentinels</b> hunt you. Touch = damage.</li>
          <li><b>ATTACK</b> costs Fury. Killing a Sentinel heals you to full — but it returns <b>far away</b> and <b>splits into two</b>.</li>
        </ul>
      </div>

      <div class="box">
        <div class="t">CONTROLS</div>
        <ul>
          <li><b>Touch</b>: Thumbstick + POWER + ATTACK</li>
          <li><b>Keyboard</b>: Arrows + Space (POWER) + Shift (ATTACK)</li>
          <li><b>Controller</b>: Stick/D-pad + A (POWER) + B (ATTACK)</li>
        </ul>
        <div class="small" style="margin-top:10px;">
          Tip: press turns early—your intent stays buffered.
        </div>
      </div>
    </div>

    <div class="footer">
      <div style="display:flex; gap:10px; align-items:center;">
        <button id="btnResetRun" class="menuBtn">Reset Run</button>
        <button id="btnClose" class="menuBtn">Close</button>
      </div>
      <button id="btnStart" class="start">START RUN ▶</button>
    </div>
  </div>
</div>

<div id="errBox"></div>

<script>
(() => {
  // ---------------------------
  // Error overlay
  // ---------------------------
  const errBox = document.getElementById('errBox');
  function showError(msg){
    errBox.textContent = msg;
    errBox.classList.add('show');
  }
  window.addEventListener('error', (e)=>{
    showError(`JS ERROR:\n${e.message}\n\n${e.filename || ''}:${e.lineno || ''}:${e.colno || ''}\n\n${e.error?.stack || ''}`);
  });
  window.addEventListener('unhandledrejection', (e)=>{
    showError(`PROMISE REJECTION:\n${e.reason?.message || e.reason}\n\n${e.reason?.stack || ''}`);
  });

  // ---------------------------
  // Canvas + sizing
  // ---------------------------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });

  function resize() {
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
    canvas.width  = Math.max(1, Math.floor(rect.width * dpr));
    canvas.height = Math.max(1, Math.floor(rect.height * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', () => requestAnimationFrame(resize), { passive:true });
  window.addEventListener('orientationchange', () => setTimeout(resize, 90), { passive:true });
  document.addEventListener('visibilitychange', () => { if(!document.hidden) setTimeout(resize, 90); });
  resize();

  // ---------------------------
  // UI
  // ---------------------------
  const uiScore = document.getElementById('score');
  const uiMult = document.getElementById('mult');
  const uiHP = document.getElementById('hp');
  const uiHPFill = document.getElementById('hpFill');
  const uiHunger = document.getElementById('hunger');
  const uiHunFill = document.getElementById('hunFill');
  const uiFury = document.getElementById('fury');
  const uiFurFill = document.getElementById('furFill');
  const uiStage = document.getElementById('stage');
  const uiPadHint = document.getElementById('padHint');
  const uiExitState = document.getElementById('exitState');
  const uiPelLeft = document.getElementById('pelLeft');

  const btnPower = document.getElementById('btnPower');
  const btnAttack  = document.getElementById('btnAttack');

  const modalBack = document.getElementById('modalBack');
  const btnStart = document.getElementById('btnStart');
  const btnClose = document.getElementById('btnClose');
  const btnResetRun = document.getElementById('btnResetRun');
  const menuBtn = document.getElementById('menuBtn');

  const toast = document.getElementById('toast');
  function showToast(msg){
    toast.textContent = msg;
    toast.classList.add('show');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>toast.classList.remove('show'), 900);
  }

  // ---------------------------
  // Modal
  // ---------------------------
  let paused = false;
  let last = performance.now();

  function openModal(){
    modalBack.classList.add('show');
    paused = true;
    requestAnimationFrame(resize);
  }
  function closeModal(){
    modalBack.classList.remove('show');
    paused = false;
    requestAnimationFrame(() => {
      resize();
      last = performance.now();
      render(0);
    });
  }
  btnStart.addEventListener('click', ()=>{ closeModal(); requestAnimationFrame(resize); });
  btnClose.addEventListener('click', ()=>{ closeModal(); });
  btnResetRun.addEventListener('click', ()=>{ resetRun(); closeModal(); });
  menuBtn.addEventListener('click', ()=> openModal());

  const FIRST_KEY = 'maze_hunger_seen_rules_v3';
  if(!localStorage.getItem(FIRST_KEY)){
    openModal();
    localStorage.setItem(FIRST_KEY, '1');
  }

  // ---------------------------
  // Constants
  // ---------------------------
  const CELL = 22;
  const MAZE_W = 25;
  const MAZE_H = 19;
  const WALL = 1, FLOOR = 0;

  // Turning feel
  const TURN_EPS = 0.18;
  const CENTER_PULL = 16.0;

  // Progression
  const EXIT_THRESHOLD_BASE = 30;
  const EXIT_THRESHOLD_STAGE_DECAY = 1;

  // Combat
  const MAX_HP = 100;
  const MAX_FURY = 100;
  const FURY_PER_PELLET = 4;
  const ATTACK_COST = 20;
  const ATTACK_CD = 0.28;
  const ATTACK_RANGE = 1; // cells ahead

  // Enemies
  const BASE_SENTINEL_HP = 5;
  const RESPAWN_DELAY = 1.0; // seconds
  const MIN_RESPAWN_DIST = 10;
  const MAX_SENTINELS = 10;

  // ---------------------------
  // Helpers
  // ---------------------------
  function mulberry32(seed){
    return function(){
      let t = seed += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }

  function key(x,y){ return (x<<16)|y; }
  function unkey(k){ return {x:(k>>>16)&0xffff, y:k&0xffff}; }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

  function manhattan(ax,ay,bx,by){ return Math.abs(ax-bx) + Math.abs(ay-by); }

  // ---------------------------
  // Maze gen
  // ---------------------------
  function genMaze(stage) {
    const seed = (Date.now() ^ (stage*99991)) >>> 0;
    const rand = mulberry32(seed);
    const w = MAZE_W, h = MAZE_H;
    const grid = Array.from({length:h}, ()=> Array(w).fill(WALL));

    function inb(x,y){ return x>=0 && y>=0 && x<w && y<h; }
    const dirs = [{dx:2,dy:0},{dx:-2,dy:0},{dx:0,dy:2},{dx:0,dy:-2}];

    grid[1][1] = FLOOR;
    const stack = [{x:1,y:1}];
    while(stack.length){
      const cur = stack[stack.length-1];
      const options = [];
      for(const d of dirs){
        const nx = cur.x+d.dx, ny=cur.y+d.dy;
        if(inb(nx,ny) && grid[ny][nx]===WALL) options.push(d);
      }
      if(!options.length){ stack.pop(); continue; }
      const d = options[(rand()*options.length)|0];
      const nx = cur.x+d.dx, ny=cur.y+d.dy;
      grid[cur.y + d.dy/2][cur.x + d.dx/2] = FLOOR;
      grid[ny][nx] = FLOOR;
      stack.push({x:nx,y:ny});
    }

    // Loops
    const loops = Math.min(55, 14 + stage*7);
    for(let i=0;i<loops;i++){
      const x = 1 + ((rand()*(w-2))|0);
      const y = 1 + ((rand()*(h-2))|0);
      if(grid[y][x]!==WALL) continue;
      const horiz = (grid[y][x-1]===FLOOR && grid[y][x+1]===FLOOR);
      const vert  = (grid[y-1][x]===FLOOR && grid[y+1][x]===FLOOR);
      if(horiz || vert) grid[y][x]=FLOOR;
    }

    // Pellets
    const pellets = new Set();
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        if(grid[y][x]===FLOOR && !(x===1 && y===1)){
          const density = 0.90 - Math.min(0.18, stage*0.015);
          if(rand() < density) pellets.add(key(x,y));
        }
      }
    }

    // Exit: far from start
    let exit = {x:w-2,y:h-2};
    let best = -1;
    for(let tries=0;tries<260;tries++){
      const x = 1 + ((rand()*(w-2))|0);
      const y = 1 + ((rand()*(h-2))|0);
      if(grid[y][x]!==FLOOR) continue;
      const d = (x-1)*(x-1)+(y-1)*(y-1);
      if(d>best){best=d; exit={x,y};}
    }

    return { grid, pellets, exit };
  }

  // ---------------------------
  // State
  // ---------------------------
  const state = {
    stage: 1,
    score: 0,
    hp: MAX_HP,
    hunger: 0,
    fury: 0,
    multiplier: 1.0,
    multDecay: 0,

    powerTimer: 0,
    powerCooldown: 0,

    attackCD: 0,
    attackFlash: 0,

    hitFlash: 0,
    map: null,
    gameOver: false,
    exitReady: false,

    rand: mulberry32((Date.now()>>>0) ^ 0xA5A5A5),

    p: {
      x:1,y:1, px:1,py:1,
      dir:{x:1,y:0},
      want:{x:1,y:0},
      speed: 7.1,
      invuln: 0
    },

    enemies: [],      // active sentinels
    respawns: []      // pending respawns {t,x,y,level,speed,hpMax}
  };

  function isWall(x,y){
    const g = state.map.grid;
    if(y<0||y>=g.length||x<0||x>=g[0].length) return true;
    return g[y][x]===WALL;
  }
  function canMoveTo(x,y){ return !isWall(x,y); }

  function atCellCenter(px,py){
    const cx = Math.round(px), cy = Math.round(py);
    return (Math.abs(px-cx) < 0.10 && Math.abs(py-cy) < 0.10);
  }

  // BFS next step (queue index = no slow shift)
  function nextStepToward(sx,sy,tx,ty){
    const w = MAZE_W, h = MAZE_H;
    const start = sy*w+sx, goal = ty*w+tx;
    if(start===goal) return {x:sx,y:sy};

    const prev = new Int32Array(w*h);
    prev.fill(-1);

    const q = new Int32Array(w*h);
    let qh=0, qt=0;
    q[qt++] = start;
    prev[start]=start;

    while(qh<qt){
      const cur = q[qh++];
      if(cur===goal) break;

      const cx = cur % w;
      const cy = (cur / w) | 0;

      // 4-neigh
      if(cx+1<w){
        const n=cur+1;
        if(prev[n]<0 && !isWall(cx+1,cy)){ prev[n]=cur; q[qt++]=n; }
      }
      if(cx-1>=0){
        const n=cur-1;
        if(prev[n]<0 && !isWall(cx-1,cy)){ prev[n]=cur; q[qt++]=n; }
      }
      if(cy+1<h){
        const n=cur+w;
        if(prev[n]<0 && !isWall(cx,cy+1)){ prev[n]=cur; q[qt++]=n; }
      }
      if(cy-1>=0){
        const n=cur-w;
        if(prev[n]<0 && !isWall(cx,cy-1)){ prev[n]=cur; q[qt++]=n; }
      }
    }

    if(prev[goal]<0) return {x:sx,y:sy}; // unreachable

    let cur = goal;
    let p = prev[cur];
    while(p !== start && p !== cur){
      cur = p; p = prev[cur];
    }
    return {x:cur%w, y:(cur/w)|0};
  }

  function findFarSpawn(px,py, minDist){
    const grid = state.map.grid;
    const w = MAZE_W, h = MAZE_H;

    // Try random samples first
    for(let tries=0; tries<600; tries++){
      const x = 1 + ((state.rand()*(w-2))|0);
      const y = 1 + ((state.rand()*(h-2))|0);
      if(grid[y][x]!==FLOOR) continue;
      if(manhattan(x,y,px,py) < minDist) continue;

      // avoid spawning on exit tile too (feels cheap)
      if(x===state.map.exit.x && y===state.map.exit.y) continue;
      return {x,y};
    }

    // Fallback: pick farthest floor tile
    let best = null;
    let bestD = -1;
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        if(grid[y][x]!==FLOOR) continue;
        if(x===state.map.exit.x && y===state.map.exit.y) continue;
        const d = manhattan(x,y,px,py);
        if(d>bestD){ bestD=d; best={x,y}; }
      }
    }
    return best || {x: w-2, y: h-2};
  }

  function spawnSentinelAt(x,y, level=1, speed=5.6, hpMax=BASE_SENTINEL_HP){
    if(state.enemies.length >= MAX_SENTINELS) return;
    const s = {
      id: (Math.random().toString(36).slice(2) + Date.now().toString(36)),
      x, y,
      px:x, py:y,
      dx:0, dy:0,
      speed,
      stepAge: 0,
      stuckAge: 0,
      invuln: 0.0, // spawn protection
      level,
      hpMax,
      hp: hpMax
    };
    state.enemies.push(s);
  }

  function spawnStageSentinels(){
    state.enemies.length = 0;
    state.respawns.length = 0;

    const count = Math.min(MAX_SENTINELS, 1 + Math.floor(state.stage / 2));
    const p = state.p;
    for(let i=0;i<count;i++){
      const pos = findFarSpawn(p.x,p.y, MIN_RESPAWN_DIST);
      spawnSentinelAt(pos.x,pos.y, 1, 5.6, BASE_SENTINEL_HP);
    }
  }

  function resetStage(){
    state.map = genMaze(state.stage);

    // player
    state.p.x = state.p.px = 1;
    state.p.y = state.p.py = 1;
    state.p.dir = {x:1,y:0};
    state.p.want = {x:1,y:0};
    state.p.invuln = 0;

    // stage sentinels
    spawnStageSentinels();

    state.exitReady = false;
    state.powerTimer = 0;
    state.powerCooldown = 0;
    state.attackCD = 0;
    state.attackFlash = 0;

    showToast(`Stage ${state.stage}`);
  }

  function resetRun(){
    state.stage = 1;
    state.score = 0;
    state.hp = MAX_HP;
    state.hunger = 0;
    state.fury = 0;
    state.multiplier = 1.0;
    state.multDecay = 0;
    state.gameOver = false;
    state.hitFlash = 0;

    resetStage();
    showToast('New Run');
  }

  resetStage();

  // ---------------------------
  // Input (keyboard + gamepad + touch)
  // ---------------------------
  const input = {
    up:false, down:false, left:false, right:false,
    power:false, attack:false
  };

  function setWanted(dir){ state.p.want = dir; }

  function setWantedFromInput(){
    // last-pressed wins
    if(input.left)  setWanted({x:-1,y:0});
    if(input.right) setWanted({x: 1,y:0});
    if(input.up)    setWanted({x: 0,y:-1});
    if(input.down)  setWanted({x: 0,y: 1});
  }

  function bindPress(el, onDown, onUp){
    const down = (e)=>{ e.preventDefault(); onDown(); };
    const up = (e)=>{ e.preventDefault(); onUp(); };
    el.addEventListener('pointerdown', down);
    el.addEventListener('pointerup', up);
    el.addEventListener('pointercancel', up);
    el.addEventListener('pointerleave', up);
  }

  bindPress(btnPower, ()=>{ input.power=true; }, ()=>{ input.power=false; });
  bindPress(btnAttack,  ()=>{ input.attack=true; }, ()=>{ input.attack=false; });

  window.addEventListener('keydown', (e)=>{
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' ','Shift','Escape'].includes(e.key)) e.preventDefault();
    if(e.key==='Escape'){ openModal(); return; }
    if(paused) return;

    if(e.key==='ArrowUp') input.up = true;
    if(e.key==='ArrowDown') input.down = true;
    if(e.key==='ArrowLeft') input.left = true;
    if(e.key==='ArrowRight') input.right = true;
    if(e.key===' ') input.power = true;
    if(e.key==='Shift') input.attack = true;

    setWantedFromInput();
  }, {passive:false});

  window.addEventListener('keyup', (e)=>{
    if(paused) return;

    if(e.key==='ArrowUp') input.up = false;
    if(e.key==='ArrowDown') input.down = false;
    if(e.key==='ArrowLeft') input.left = false;
    if(e.key==='ArrowRight') input.right = false;
    if(e.key===' ') input.power = false;
    if(e.key==='Shift') input.attack = false;

    setWantedFromInput();
  });

  // Gamepad
  let lastPadConnected = false;
  window.addEventListener('gamepadconnected', ()=>{
    lastPadConnected = true;
    uiPadHint.textContent = 'Gamepad connected';
    showToast('Gamepad connected');
  });
  window.addEventListener('gamepaddisconnected', ()=>{
    uiPadHint.textContent = 'Touch / Keys / Gamepad';
    showToast('Gamepad disconnected');
  });

  function pollGamepad(){
    const pads = navigator.getGamepads ? navigator.getGamepads() : [];
    const gp = pads && pads[0];
    if(!gp) return;

    if(!lastPadConnected){
      lastPadConnected = true;
      uiPadHint.textContent = 'Gamepad active';
      showToast('Gamepad active');
    }

    const dead = 0.35;
    const axX = gp.axes[0] || 0;
    const axY = gp.axes[1] || 0;

    const dUp = gp.buttons[12]?.pressed;
    const dDown = gp.buttons[13]?.pressed;
    const dLeft = gp.buttons[14]?.pressed;
    const dRight = gp.buttons[15]?.pressed;

    input.up = (axY < -dead) || !!dUp;
    input.down = (axY > dead) || !!dDown;
    input.left = (axX < -dead) || !!dLeft;
    input.right = (axX > dead) || !!dRight;

    input.power = !!gp.buttons[0]?.pressed;   // A
    input.attack  = !!gp.buttons[1]?.pressed; // B

    if(gp.buttons[9]?.pressed){ openModal(); }

    if(!paused) setWantedFromInput();
  }

  // Virtual joystick (4-way snap)
  const joy = document.getElementById('joy');
  const knob = document.getElementById('joyKnob');

  let joyActive = false;
  let joyPid = -1;
  let joyRect = null;
  let joyCx = 0, joyCy = 0;
  let joyRadius = 1;

  function joyReset(){
    knob.style.left = '50%';
    knob.style.top = '50%';
    input.up = input.down = input.left = input.right = false;
    setWantedFromInput();
  }

  function joyUpdateFromDelta(dx,dy){
    const mag = Math.hypot(dx,dy);
    const dead = joyRadius * 0.18;

    // move knob visually (clamped)
    const cl = mag > joyRadius ? (joyRadius/mag) : 1;
    const kx = dx * cl;
    const ky = dy * cl;
    knob.style.left = `${50 + (kx/joyRadius)*34}%`;
    knob.style.top  = `${50 + (ky/joyRadius)*34}%`;

    // set direction (4-way snap)
    input.up = input.down = input.left = input.right = false;

    if(mag < dead){
      setWantedFromInput();
      return;
    }

    if(Math.abs(dx) > Math.abs(dy)){
      if(dx > 0) input.right = true;
      else input.left = true;
    } else {
      if(dy > 0) input.down = true;
      else input.up = true;
    }
    setWantedFromInput();
  }

  joy.addEventListener('pointerdown', (e)=>{
    e.preventDefault();
    if(paused) return;
    joyActive = true;
    joyPid = e.pointerId;
    joy.setPointerCapture(joyPid);

    joyRect = joy.getBoundingClientRect();
    joyCx = joyRect.left + joyRect.width/2;
    joyCy = joyRect.top + joyRect.height/2;
    joyRadius = joyRect.width * 0.34;

    joyUpdateFromDelta(e.clientX - joyCx, e.clientY - joyCy);
  });

  joy.addEventListener('pointermove', (e)=>{
    if(!joyActive || e.pointerId !== joyPid) return;
    e.preventDefault();
    joyUpdateFromDelta(e.clientX - joyCx, e.clientY - joyCy);
  });

  function joyEnd(e){
    if(e && e.pointerId !== joyPid) return;
    joyActive = false;
    joyPid = -1;
    joyReset();
  }

  joy.addEventListener('pointerup', joyEnd);
  joy.addEventListener('pointercancel', joyEnd);
  joy.addEventListener('pointerleave', joyEnd);

  // ---------------------------
  // Actions
  // ---------------------------
  function tryPower(){
    if(state.powerCooldown>0 || state.powerTimer>0) return;
    state.powerTimer = 0.85;
    state.powerCooldown = 2.2;
    showToast('POWER');
  }

  function tryAttack(){
    if(state.attackCD>0) return;
    if(state.fury < ATTACK_COST) {
      state.attackCD = 0.12; // tiny lockout to avoid spam
      return;
    }
    state.fury = clamp(state.fury - ATTACK_COST, 0, MAX_FURY);
    state.attackCD = ATTACK_CD;
    state.attackFlash = 0.16;

    // hit tile in front (sword)
    const p = state.p;
    const dir = (p.dir.x===0 && p.dir.y===0) ? p.want : p.dir;
    const tx = p.x + dir.x * ATTACK_RANGE;
    const ty = p.y + dir.y * ATTACK_RANGE;

    for(const s of state.enemies){
      if(s.invuln>0) continue;
      if(s.x===tx && s.y===ty){
        s.hp -= 1;
        showToast(`HIT (${s.hp}/${s.hpMax})`);
        if(s.hp <= 0){
          killSentinel(s);
        }
        break;
      }
    }
  }

  function killSentinel(s){
    // full heal
    state.hp = MAX_HP;
    state.hitFlash = 0.25;

    // remove from active list
    const idx = state.enemies.indexOf(s);
    if(idx>=0) state.enemies.splice(idx,1);

    // schedule respawn + split into 2
    const p = state.p;
    const pos = findFarSpawn(p.x,p.y, MIN_RESPAWN_DIST);

    const childLevel = (s.level || 1) + 1;
    const childHpMax = Math.max(2, Math.floor((s.hpMax || BASE_SENTINEL_HP) * 0.7));
    const childSpeed = Math.min(8.0, (s.speed || 5.6) * 1.05);

    state.respawns.push({ t: RESPAWN_DELAY, x: pos.x, y: pos.y, level: childLevel, hpMax: childHpMax, speed: childSpeed, count: 2 });

    showToast('KILL → FULL HEAL (splits!)');
  }

  // ---------------------------
  // Turning helpers (intent buffer + centering)
  // ---------------------------
  function isPerpendicular(a,b){
    return (a.x !== 0 && b.y !== 0) || (a.y !== 0 && b.x !== 0);
  }

  function applyAutoCenter(p, dt){
    const cx = Math.round(p.px);
    const cy = Math.round(p.py);

    if(p.dir.x !== 0){
      const dy = (cy - p.py);
      p.py += dy * (1 - Math.exp(-CENTER_PULL * dt));
    } else if(p.dir.y !== 0){
      const dx = (cx - p.px);
      p.px += dx * (1 - Math.exp(-CENTER_PULL * dt));
    }
  }

  function tryApplyBufferedTurn(p){
    const want = p.want;
    if(!want || (want.x===0 && want.y===0)) return;

    const cx = Math.round(p.px);
    const cy = Math.round(p.py);

    const nearX = Math.abs(p.px - cx) <= TURN_EPS;
    const nearY = Math.abs(p.py - cy) <= TURN_EPS;

    // if stopped
    if(p.dir.x===0 && p.dir.y===0){
      if(nearX && nearY && canMoveTo(cx + want.x, cy + want.y)){
        p.px = cx; p.py = cy; p.x = cx; p.y = cy;
        p.dir = {x: want.x, y: want.y};
      }
      return;
    }

    // perpendicular turn at intersection
    if(isPerpendicular(p.dir, want) && nearX && nearY && canMoveTo(cx + want.x, cy + want.y)){
      p.px = cx; p.py = cy; p.x = cx; p.y = cy;
      p.dir = {x: want.x, y: want.y};
      return;
    }

    // allow reverse on center
    if((want.x === -p.dir.x && want.y === -p.dir.y) && nearX && nearY){
      if(canMoveTo(cx + want.x, cy + want.y)){
        p.px = cx; p.py = cy; p.x = cx; p.y = cy;
        p.dir = {x: want.x, y: want.y};
      }
    }
  }

  // ---------------------------
  // Loop
  // ---------------------------
  canvas.addEventListener('pointerdown', ()=>{
    if(state.gameOver){
      resetRun();
      requestAnimationFrame(()=>{ resize(); render(0); });
    }
  });

  function stepEnemy(s, dt){
    s.invuln = Math.max(0, s.invuln - dt);
    s.stepAge += dt;

    // update cell lock
    if(atCellCenter(s.px,s.py)){
      const cx = Math.round(s.px);
      const cy = Math.round(s.py);
      s.x = cx; s.y = cy;
      s.px = cx; s.py = cy;
    }

    // choose direction periodically or at cell center
    if(atCellCenter(s.px,s.py) || s.stepAge > 0.20){
      s.stepAge = 0;

      const p = state.p;
      const step = nextStepToward(s.x,s.y, p.x,p.y);

      let dx = clamp(step.x - s.x, -1, 1);
      let dy = clamp(step.y - s.y, -1, 1);

      // If BFS can't find a move (or returns same cell), pick a valid neighbor to avoid freezing.
      if((dx===0 && dy===0) || !canMoveTo(s.x+dx, s.y+dy)){
        const opts = [];
        if(canMoveTo(s.x+1,s.y)) opts.push({dx:1,dy:0});
        if(canMoveTo(s.x-1,s.y)) opts.push({dx:-1,dy:0});
        if(canMoveTo(s.x,s.y+1)) opts.push({dx:0,dy:1});
        if(canMoveTo(s.x,s.y-1)) opts.push({dx:0,dy:-1});
        if(opts.length){
          const pick = opts[(state.rand()*opts.length)|0];
          dx = pick.dx; dy = pick.dy;
        }
      }

      // Track stuckness
      if(dx===0 && dy===0){
        s.stuckAge += dt;
      } else {
        s.stuckAge = 0;
      }

      // If "stuck" too long, force random move
      if(s.stuckAge > 0.5){
        const opts = [];
        if(canMoveTo(s.x+1,s.y)) opts.push({dx:1,dy:0});
        if(canMoveTo(s.x-1,s.y)) opts.push({dx:-1,dy:0});
        if(canMoveTo(s.x,s.y+1)) opts.push({dx:0,dy:1});
        if(canMoveTo(s.x,s.y-1)) opts.push({dx:0,dy:-1});
        if(opts.length){
          const pick = opts[(state.rand()*opts.length)|0];
          dx = pick.dx; dy = pick.dy;
          s.stuckAge = 0;
        }
      }

      s.dx = dx; s.dy = dy;
    }

    const spd = s.speed;
    if(s.dx || s.dy){
      s.px += s.dx * spd * dt;
      s.py += s.dy * spd * dt;

      // stop at walls (guard)
      const cx = Math.round(s.px);
      const cy = Math.round(s.py);
      if(!canMoveTo(cx,cy)){
        s.px = s.x; s.py = s.y;
        s.dx = 0; s.dy = 0;
      }
    }
  }

  function tick(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    pollGamepad();

    if(paused || state.gameOver){
      render(dt);
      return;
    }

    // timers
    state.p.invuln = Math.max(0, state.p.invuln - dt);
    state.powerTimer = Math.max(0, state.powerTimer - dt);
    state.powerCooldown = Math.max(0, state.powerCooldown - dt);
    state.attackCD = Math.max(0, state.attackCD - dt);
    state.attackFlash = Math.max(0, state.attackFlash - dt);
    state.hitFlash = Math.max(0, state.hitFlash - dt*1.8);

    // button state
    btnPower.classList.toggle('active', state.powerTimer>0);
    btnPower.classList.toggle('disabled', state.powerCooldown>0 && state.powerTimer<=0);
    btnPower.classList.toggle('hot', state.powerCooldown<=0 && state.powerTimer<=0);

    btnAttack.classList.toggle('active', state.attackFlash>0);
    btnAttack.classList.toggle('disabled', state.attackCD>0);
    btnAttack.classList.toggle('hot', state.fury >= ATTACK_COST && state.attackCD<=0);

    // actions
    if(input.power) tryPower();
    if(input.attack) tryAttack();

    // hunger + multiplier
    const movingInput = (input.up||input.down||input.left||input.right) || (state.p.dir.x!==0||state.p.dir.y!==0);

    state.hunger += dt * (movingInput ? 5.0 : 8.5);
    state.hunger = clamp(state.hunger, 0, 100);

    if(state.hunger >= 100){
      state.hp -= dt * 11.0;
      state.hitFlash = Math.max(state.hitFlash, 0.25);
    }

    if(movingInput){
      state.multiplier += dt * 0.18;
      state.multiplier = clamp(state.multiplier, 1.0, 6.0);
      state.multDecay = 0;
    } else {
      state.multDecay += dt;
      if(state.multDecay > 0.35){
        state.multiplier -= dt * 0.42;
        state.multiplier = clamp(state.multiplier, 1.0, 6.0);
      }
    }

    // PLAYER
    const p = state.p;

    applyAutoCenter(p, dt);
    tryApplyBufferedTurn(p);

    if(atCellCenter(p.px, p.py)){
      const cx = Math.round(p.px);
      const cy = Math.round(p.py);
      p.x = cx; p.y = cy;
      p.px = cx; p.py = cy;

      // blocked ahead -> stop
      if(!canMoveTo(cx+p.dir.x, cy+p.dir.y)){
        p.dir = {x:0,y:0};
      }

      // eat pellet
      const k = key(p.x,p.y);
      if(state.map.pellets.has(k)){
        state.map.pellets.delete(k);
        state.score += Math.round(10 * state.multiplier);
        state.hunger = clamp(state.hunger - 14, 0, 100);
        state.fury = clamp(state.fury + FURY_PER_PELLET, 0, MAX_FURY);
        if(state.hunger > 70) state.hp = clamp(state.hp + 0.6, 0, MAX_HP);
      }
    }

    const baseSpeed = p.speed + (state.hunger/100)*1.05;
    const spd = baseSpeed * (state.powerTimer>0 ? 1.65 : 1.0);

    if(p.dir.x!==0 || p.dir.y!==0){
      const nx = p.px + p.dir.x * spd * dt;
      const ny = p.py + p.dir.y * spd * dt;

      const cx = Math.round(p.px);
      const cy = Math.round(p.py);

      if(p.dir.x!==0){
        const nextCellX = p.dir.x>0 ? cx+1 : cx-1;
        const boundary = cx + (p.dir.x>0 ? 0.5 : -0.5);
        if(!canMoveTo(nextCellX, cy) && ((p.dir.x>0 && nx>boundary) || (p.dir.x<0 && nx<boundary))){
          p.px = cx; p.py = cy;
          p.dir = {x:0,y:0};
        } else {
          p.px = nx; p.py = ny;
        }
      } else {
        const nextCellY = p.dir.y>0 ? cy+1 : cy-1;
        const boundary = cy + (p.dir.y>0 ? 0.5 : -0.5);
        if(!canMoveTo(cx, nextCellY) && ((p.dir.y>0 && ny>boundary) || (p.dir.y<0 && ny<boundary))){
          p.px = cx; p.py = cy;
          p.dir = {x:0,y:0};
        } else {
          p.px = nx; p.py = ny;
        }
      }
    }

    // Exit
    const pelletsLeft = state.map.pellets.size;
    const threshold = Math.max(0, EXIT_THRESHOLD_BASE - (state.stage*EXIT_THRESHOLD_STAGE_DECAY));
    state.exitReady = pelletsLeft <= threshold;

    const exit = state.map.exit;
    if(p.x===exit.x && p.y===exit.y && state.exitReady){
      state.stage++;
      state.score += Math.round(75 * state.multiplier);
      resetStage();
      render(dt);
      return;
    }

    // ENEMIES
    for(const s of state.enemies){
      stepEnemy(s, dt);
    }

    // Collision
    for(const s of state.enemies){
      if(p.invuln>0) break;
      const dist = Math.hypot((p.px - s.px), (p.py - s.py));
      if(dist < 0.40){
        state.hp -= 19;
        p.invuln = 0.85;
        state.multiplier = 1.0;
        state.hitFlash = 1.0;
        showToast('HIT!');
        break;
      }
    }

    // Respawns (splitting)
    for(let i=state.respawns.length-1; i>=0; i--){
      const r = state.respawns[i];
      r.t -= dt;
      if(r.t <= 0){
        state.respawns.splice(i,1);

        // spawn two, slightly separated if possible
        const ppos = findFarSpawn(p.x,p.y, MIN_RESPAWN_DIST);
        spawnSentinelAt(ppos.x, ppos.y, r.level, r.speed, r.hpMax);

        const ppos2 = findFarSpawn(p.x,p.y, MIN_RESPAWN_DIST);
        spawnSentinelAt(ppos2.x, ppos2.y, r.level, r.speed, r.hpMax);
      }
    }

    // Death
    state.hp = clamp(state.hp, 0, MAX_HP);
    if(state.hp<=0){
      state.gameOver = true;
      showToast('SYSTEM FAILURE — Tap to restart');
    }

    // UI
    uiScore.textContent = String(state.score);
    uiMult.textContent = `×${state.multiplier.toFixed(1)} (${movingInput ? 'rolling' : 'decay'})`;

    uiHP.textContent = String(Math.round(state.hp));
    uiHunger.textContent = String(Math.round(state.hunger));
    uiFury.textContent = String(Math.round(state.fury));
    uiStage.textContent = String(state.stage);

    uiHPFill.style.width = `${state.hp}%`;
    uiHPFill.classList.toggle('danger', state.hp<35);
    uiHPFill.classList.toggle('good', state.hp>=35);

    uiHunFill.style.width = `${state.hunger}%`;
    uiFurFill.style.width = `${(state.fury/MAX_FURY)*100}%`;

    uiExitState.textContent = state.exitReady ? 'READY' : 'LOCKED';
    uiExitState.style.color = state.exitReady ? 'var(--good)' : 'var(--ink)';
    uiPelLeft.textContent = `pellets: ${pelletsLeft} (need ≤ ${threshold})`;

    render(dt);
  }

  // ---------------------------
  // Render
  // ---------------------------
  function render(dt){
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;

    const mazePxW = MAZE_W * CELL;
    const mazePxH = MAZE_H * CELL;
    const scale = Math.min((w-18)/mazePxW, (h-18)/mazePxH);
    const drawW = mazePxW * scale;
    const drawH = mazePxH * scale;
    const ox = (w - drawW)/2;
    const oy = (h - drawH)/2;

    ctx.fillStyle = '#04040e';
    ctx.fillRect(0,0,w,h);

    if(state.hitFlash>0){
      ctx.fillStyle = `rgba(255,90,122,${0.18*state.hitFlash})`;
      ctx.fillRect(0,0,w,h);
    }

    ctx.save();
    ctx.translate(ox, oy);
    ctx.scale(scale, scale);

    // tiles
    ctx.shadowBlur = 10;
    ctx.shadowColor = 'rgba(125,249,255,0.35)';
    for(let y=0; y<MAZE_H; y++){
      for(let x=0; x<MAZE_W; x++){
        if(state.map.grid[y][x]===WALL){
          ctx.fillStyle = 'rgba(125,249,255,0.11)';
          ctx.fillRect(x*CELL, y*CELL, CELL, CELL);
        } else {
          ctx.fillStyle = 'rgba(255,255,255,0.02)';
          ctx.fillRect(x*CELL, y*CELL, CELL, CELL);
        }
      }
    }

    // pellets
    ctx.shadowBlur = 8;
    ctx.shadowColor = 'rgba(232,233,255,0.25)';
    for(const k of state.map.pellets){
      const {x,y} = unkey(k);
      const cx = x*CELL + CELL*0.5;
      const cy = y*CELL + CELL*0.5;
      ctx.beginPath();
      ctx.arc(cx, cy, 3.2, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(232,233,255,0.70)';
      ctx.fill();
    }

    // exit
    const ex = state.map.exit.x*CELL;
    const ey = state.map.exit.y*CELL;
    ctx.shadowBlur = 16;
    ctx.shadowColor = state.exitReady ? 'rgba(124,255,154,0.55)' : 'rgba(255,211,110,0.22)';
    ctx.fillStyle = state.exitReady ? 'rgba(124,255,154,0.14)' : 'rgba(255,211,110,0.06)';
    ctx.fillRect(ex+2, ey+2, CELL-4, CELL-4);
    ctx.strokeStyle = state.exitReady ? 'rgba(124,255,154,0.75)' : 'rgba(255,211,110,0.35)';
    ctx.lineWidth = 2;
    ctx.strokeRect(ex+4, ey+4, CELL-8, CELL-8);

    // enemies
    for(const s of state.enemies){
      const ecx = s.px*CELL + CELL*0.5;
      const ecy = s.py*CELL + CELL*0.5;

      ctx.shadowBlur = 14;
      ctx.shadowColor = 'rgba(255,90,122,0.55)';
      ctx.beginPath();
      ctx.arc(ecx, ecy, CELL*0.34, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,90,122,0.83)';
      ctx.fill();

      // tiny hp pip
      const frac = s.hpMax>0 ? (s.hp/s.hpMax) : 0;
      ctx.shadowBlur = 0;
      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      ctx.fillRect(ecx - CELL*0.36, ecy - CELL*0.55, CELL*0.72, 4);
      ctx.fillStyle = 'rgba(255,211,110,0.85)';
      ctx.fillRect(ecx - CELL*0.36, ecy - CELL*0.55, CELL*0.72*frac, 4);
    }

    // player
    const p = state.p;
    const pcx = p.px*CELL + CELL*0.5;
    const pcy = p.py*CELL + CELL*0.5;
    const mouth = 0.55 + 0.25*Math.sin(performance.now()/85);
    const ang = Math.atan2(p.dir.y, p.dir.x);

    ctx.shadowBlur = 16;
    ctx.shadowColor = (p.invuln>0) ? 'rgba(125,249,255,0.6)' : 'rgba(232,233,255,0.35)';
    ctx.beginPath();
    ctx.moveTo(pcx, pcy);
    ctx.arc(pcx, pcy, CELL*0.36, ang+mouth, ang+(Math.PI*2-mouth));
    ctx.closePath();
    ctx.fillStyle = (p.invuln>0) ? 'rgba(125,249,255,0.95)' : 'rgba(232,233,255,0.90)';
    ctx.fill();

    // power ring
    if(state.powerTimer>0){
      ctx.shadowBlur = 22;
      ctx.shadowColor = 'rgba(125,249,255,0.6)';
      ctx.beginPath();
      ctx.arc(pcx, pcy, CELL*0.58, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(125,249,255,0.65)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    // attack slash
    if(state.attackFlash>0){
      const dir = (p.dir.x===0 && p.dir.y===0) ? p.want : p.dir;
      const tx = (p.x + dir.x)*CELL + CELL*0.5;
      const ty = (p.y + dir.y)*CELL + CELL*0.5;

      ctx.shadowBlur = 18;
      ctx.shadowColor = 'rgba(255,211,110,0.65)';
      ctx.strokeStyle = 'rgba(255,211,110,0.85)';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(pcx, pcy);
      ctx.lineTo(tx, ty);
      ctx.stroke();
    }

    // paused / gameover overlays
    if(paused){
      ctx.shadowBlur = 0;
      ctx.fillStyle = 'rgba(0,0,0,0.62)';
      ctx.fillRect(0,0,MAZE_W*CELL,MAZE_H*CELL);
      ctx.fillStyle = 'rgba(232,233,255,0.92)';
      ctx.font = 'bold 22px system-ui';
      ctx.textAlign='center';
      ctx.fillText('PAUSED', (MAZE_W*CELL)/2, (MAZE_H*CELL)/2);
      ctx.font = '13px system-ui';
      ctx.fillStyle = 'rgba(232,233,255,0.68)';
      ctx.fillText('Close the menu to resume', (MAZE_W*CELL)/2, (MAZE_H*CELL)/2 + 18);
    }

    if(state.gameOver){
      ctx.shadowBlur = 0;
      ctx.fillStyle = 'rgba(0,0,0,0.70)';
      ctx.fillRect(0,0,MAZE_W*CELL,MAZE_H*CELL);
      ctx.fillStyle = 'rgba(232,233,255,0.96)';
      ctx.font = 'bold 26px system-ui';
      ctx.textAlign='center';
      ctx.fillText('SYSTEM FAILURE', (MAZE_W*CELL)/2, (MAZE_H*CELL)/2 - 12);
      ctx.font = '14px system-ui';
      ctx.fillStyle = 'rgba(232,233,255,0.75)';
      ctx.fillText('Tap to restart', (MAZE_W*CELL)/2, (MAZE_H*CELL)/2 + 18);
    }

    ctx.restore();
  }

  // Safe loop
  function loop(now){
    try{
      tick(now);
    }catch(e){
      showError(`RUNTIME CRASH:\n${e.message}\n\n${e.stack || ''}`);
      return;
    }
    requestAnimationFrame(loop);
  }

  render(0);
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
