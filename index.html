<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover"/>
  <title>MAZE // HUNGER — Vertical Slice</title>

  <style>
    :root{
      --bg:#06070b;
      --ink:#e8e9ff;
      --dim:#9aa0c8;
      --accent:#7df9ff;
      --danger:#ff5a7a;
      --good:#7CFF9A;
      --gold:#ffd36e;

      --pad: 10px;

      /* Guaranteed room for joystick/buttons, regardless of stats count */
      --controlsH: clamp(150px, 22dvh, 210px);
      --statsH: clamp(108px, 16dvh, 150px);
    }

    html,body{
      margin:0;
      background:var(--bg);
      color:var(--ink);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      overflow:hidden;
      height:100%;
    }

    body{
      height: 100dvh;
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);
      box-sizing:border-box;
    }

    #wrap{
      height:100%;
      display:flex;
      flex-direction:column;
      min-height:0;
    }

    #gameArea{
      flex: 1 1 auto;
      min-height:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: var(--pad);
      box-sizing:border-box;
    }

    canvas{
      width:100%;
      height:100%;
      background:#04040e;
      border-radius:16px;
      box-shadow: 0 16px 60px rgba(0,0,0,.55);
      touch-action:none;
      display:block;
    }

    /* --- NEW UI LAYOUT: stats strip + fixed controls row --- */
    #ui{
      flex: 0 0 auto;
      background:linear-gradient(180deg, rgba(11,13,27,.92), rgba(8,9,20,.98));
      border-top:1px solid rgba(125,249,255,.14);
      padding: 10px 12px calc(10px + env(safe-area-inset-bottom));
      box-sizing:border-box;

      display:flex;
      flex-direction:column;
      gap:10px;

      /* critical: don't let UI exceed its intended height */
      max-height: calc(var(--statsH) + var(--controlsH) + 28px);
      overflow:hidden;
    }

    /* Stats as a single horizontal carousel row */
    #stats{
      height: var(--statsH);
      display:flex;
      gap:10px;
      overflow-x:auto;
      overflow-y:hidden;
      -webkit-overflow-scrolling: touch;
      padding-bottom: 6px;
      scrollbar-width: none;
    }
    #stats::-webkit-scrollbar{ display:none; }

    .card{
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.07);
      border-radius:12px;
      padding:10px;
      box-sizing:border-box;
      min-width: 148px;
      max-width: 180px;
      flex: 0 0 auto;
    }

    .label{font-size:12px; color:var(--dim); letter-spacing:.02em;}
    .value{font-size:18px; margin-top:4px; font-weight:800;}
    .sub{font-size:12px; color:rgba(232,233,255,.72); margin-top:6px; line-height:1.25;}

    .bar{height:8px; background:rgba(255,255,255,.08); border-radius:999px; overflow:hidden; margin-top:8px;}
    .fill{height:100%; width:50%; background:var(--accent);}
    .fill.danger{background:var(--danger);}
    .fill.good{background:var(--good);}
    .fill.gold{background:var(--gold);}

    /* Controls row ALWAYS visible */
    #controlsRow{
      height: var(--controlsH);
      display:flex;
      gap:10px;
      min-height:0;
    }

    #controlsLeft, #controlsRight{
      min-height:0;
      flex:1;
      display:flex;
    }

    .btn{
      display:flex; align-items:center; justify-content:center;
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      color:var(--ink);
      font-weight:800;
      letter-spacing:.02em;
      user-select:none;
      touch-action:none;
    }
    .btn:active, .btn.active{
      background:rgba(125,249,255,.14);
      border-color:rgba(125,249,255,.35);
      box-shadow: 0 0 0 2px rgba(125,249,255,.12) inset;
    }
    .btn.disabled{
      opacity:.35;
      filter:saturate(.55);
      pointer-events:none;
    }
    .btn.attack-ready{
      background: rgba(255,211,110,.18);
      border-color: rgba(255,211,110,.55);
      box-shadow: 0 0 18px rgba(255,211,110,.45);
    }

    .actions{
      display:flex;
      flex-direction:column;
      gap:10px;
      width: 100%;
      height: 100%;
      min-height:0;
    }
    .bigBtn{flex:1; min-height:52px; font-size:15px;}
    .hint{font-size:12px; color:var(--dim); margin-top:6px; line-height:1.25;}
    .row{display:flex; gap:8px; align-items:center; justify-content:space-between;}

    /* Joystick */
    #joyWrap{
      width:100%;
      height:100%;
      min-height:0;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    #joy{
      flex: 1 1 auto;
      min-height: 96px;
      max-height: 150px;
      aspect-ratio: 1 / 1;
      width: auto;

      position:relative;
      border-radius:999px;
      background:rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.10);
      box-shadow: inset 0 0 0 2px rgba(125,249,255,.05);
      touch-action:none;
      overflow:hidden;
      align-self:flex-start;
    }
    #joyBase{
      position:absolute;
      inset:16%;
      border-radius:999px;
      border:1px dashed rgba(255,255,255,.16);
      background:rgba(0,0,0,.10);
    }
    #joyKnob{
      position:absolute;
      width:34%;
      height:34%;
      left:50%;
      top:50%;
      transform: translate(-50%,-50%);
      border-radius:999px;
      background:rgba(125,249,255,.12);
      border:1px solid rgba(125,249,255,.35);
      box-shadow: 0 10px 30px rgba(0,0,0,.45);
    }
    #joyRow{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
    }
    #menuBtn{
      padding:10px 12px;
      border-radius:12px;
      font-weight:900;
      letter-spacing:.05em;
      min-width: 92px;
    }

    #toast{
      position:absolute; left:12px; top:calc(12px + env(safe-area-inset-top));
      background:rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.10);
      padding:8px 10px; border-radius:10px;
      font-size:12px; color:var(--ink);
      opacity:0; transform:translateY(-6px);
      transition:.18s ease;
      pointer-events:none;
      backdrop-filter: blur(6px);
      z-index: 50;
    }
    #toast.show{opacity:1; transform:translateY(0);}

    /* Modal */
    #modalBack{
      position:absolute; inset:0;
      background:rgba(0,0,0,.72);
      display:none;
      align-items:center;
      justify-content:center;
      padding:14px;
      box-sizing:border-box;
      z-index: 60;
    }
    #modalBack.show{display:flex;}
    #modal{
      width:min(720px, 100%);
      background:rgba(11,13,27,.96);
      border:1px solid rgba(125,249,255,.16);
      border-radius:18px;
      box-shadow: 0 18px 70px rgba(0,0,0,.65);
      padding:16px 16px 14px;
      box-sizing:border-box;
    }
    #modal h1{margin:0 0 6px; font-size:22px; letter-spacing:.06em;}
    #modal .tag{color:rgba(232,233,255,.8); font-size:13px; margin-bottom:10px;}
    #modal .cols{display:grid; grid-template-columns: 1.2fr 1fr; gap:12px;}
    #modal .box{
      border:1px solid rgba(255,255,255,.08);
      background:rgba(255,255,255,.03);
      border-radius:14px;
      padding:12px;
    }
    #modal .box .t{font-weight:800; margin-bottom:6px;}
    #modal ul{margin:8px 0 0 18px; padding:0; color:rgba(232,233,255,.78); font-size:13px; line-height:1.3;}
    #modal .footer{display:flex; justify-content:space-between; align-items:center; gap:10px; margin-top:12px;}
    #modal .start{
      padding:12px 14px;
      border-radius:14px;
      border:1px solid rgba(125,249,255,.35);
      background:rgba(125,249,255,.14);
      color:var(--ink);
      font-weight:900;
      letter-spacing:.05em;
      cursor:pointer;
    }
    #modal .menuBtn{
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.05);
      color:rgba(232,233,255,.85);
      font-weight:800;
      cursor:pointer;
    }

    #errBox{
      position:absolute; left:12px; right:12px; bottom:calc(12px + env(safe-area-inset-bottom));
      background:rgba(0,0,0,.78);
      border:1px solid rgba(255,90,122,.35);
      border-radius:12px;
      padding:10px;
      font-size:12px;
      color:rgba(255,215,221,.95);
      display:none;
      white-space:pre-wrap;
      max-height:42vh;
      overflow:auto;
      backdrop-filter: blur(6px);
      z-index: 99;
    }
    #errBox.show{display:block;}
  </style>
</head>

<body>
<div id="wrap">
  <div id="gameArea">
    <canvas id="c"></canvas>
  </div>

  <div id="ui">
    <div id="stats">
      <div class="card"><div class="label">Score</div><div id="score" class="value">0</div><div id="mult" class="sub">×1.0</div></div>
      <div class="card"><div class="label">Integrity</div><div id="hp" class="value">100</div><div class="bar"><div id="hpFill" class="fill good"></div></div></div>
      <div class="card"><div class="label">Hunger</div><div id="hunger" class="value">0</div><div class="bar"><div id="hunFill" class="fill danger"></div></div></div>
      <div class="card"><div class="label">Fury</div><div id="fury" class="value">0</div><div class="bar"><div id="furFill" class="fill gold"></div></div><div id="atkReady" class="sub">ATTACK: —</div></div>
      <div class="card"><div class="label">Weapon</div><div id="weaponName" class="value">SWORD</div><div id="weaponInfo" class="sub">Mk1 • cost 20 • range 1</div></div>
      <div class="card"><div class="label">Stage</div><div id="stage" class="value">1</div><div id="padHint" class="sub">Touch / Keys / Gamepad</div></div>
      <div class="card"><div class="label">Exit</div><div id="exitState" class="value">LOCKED</div><div id="pelLeft" class="sub">pellets: —</div></div>
    </div>

    <div id="controlsRow">
      <div id="controlsLeft" class="card">
        <div id="joyWrap">
          <div class="label">Thumbstick</div>
          <div id="joy"><div id="joyBase"></div><div id="joyKnob"></div></div>
          <div id="joyRow">
            <div class="hint" style="margin:0;">4-way snap • buffered turns</div>
            <div id="menuBtn" class="btn">MENU</div>
          </div>
        </div>
      </div>

      <div id="controlsRight" class="card">
        <div class="actions">
          <div class="label">Actions</div>
          <div id="btnPower" class="btn bigBtn">POWER</div>
          <div id="btnAttack" class="btn bigBtn">ATTACK</div>
          <div class="hint">POWER: speed burst<br/>ATTACK: weapon action (hit → advantage)</div>
          <div class="row hint"><span>Gamepad:</span><span>A=POWER, B=ATTACK</span></div>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="toast"></div>

<div id="modalBack">
  <div id="modal">
    <h1>MAZE // HUNGER</h1>
    <div class="tag">Consume. Evolve. Escape.</div>
    <div class="cols">
      <div class="box">
        <div class="t">HOW TO PLAY</div>
        <ul>
          <li>Eat <b>Glyphs</b> to score, reduce <b>Hunger</b>, gain <b>Fury</b>.</li>
          <li>Hunger rises constantly. At max, you take damage.</li>
          <li>Clear enough glyphs to unlock the <b>Exit</b>.</li>
          <li><b>Sentinels</b> flash “!” then <b>dash</b>.</li>
          <li><b>Weapons</b>: Sword → Blaster → Flamethrower (stage-based).</li>
        </ul>
      </div>
      <div class="box">
        <div class="t">CONTROLS</div>
        <ul>
          <li><b>Touch</b>: Thumbstick + POWER + ATTACK</li>
          <li><b>Keyboard</b>: Arrows + Space + Shift</li>
          <li><b>Controller</b>: Stick/D-pad + A + B</li>
        </ul>
      </div>
    </div>
    <div class="footer">
      <div style="display:flex; gap:10px; align-items:center;">
        <button id="btnResetRun" class="menuBtn">Reset Run</button>
        <button id="btnClose" class="menuBtn">Close</button>
      </div>
      <button id="btnStart" class="start">START RUN ▶</button>
    </div>
  </div>
</div>

<div id="errBox"></div>

<script>
/* NOTE: Gameplay JS is identical to the previous “weapons + telegraphs” build.
   I’m pasting it in full below unchanged (except it references the new #controlsRow layout only via existing IDs).
*/
(() => {
  const errBox = document.getElementById('errBox');
  function showError(msg){ errBox.textContent = msg; errBox.classList.add('show'); }
  window.addEventListener('error', (e)=> showError(`JS ERROR:\n${e.message}\n\n${e.filename||''}:${e.lineno||''}:${e.colno||''}\n\n${e.error?.stack||''}`));
  window.addEventListener('unhandledrejection', (e)=> showError(`PROMISE REJECTION:\n${e.reason?.message||e.reason}\n\n${e.reason?.stack||''}`));

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });

  function resize() {
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
    canvas.width  = Math.max(1, Math.floor(rect.width * dpr));
    canvas.height = Math.max(1, Math.floor(rect.height * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', () => requestAnimationFrame(resize), { passive:true });
  window.addEventListener('orientationchange', () => setTimeout(resize, 90), { passive:true });
  document.addEventListener('visibilitychange', () => { if(!document.hidden) setTimeout(resize, 90); });
  resize();

  const uiScore = document.getElementById('score');
  const uiMult = document.getElementById('mult');
  const uiHP = document.getElementById('hp');
  const uiHPFill = document.getElementById('hpFill');
  const uiHunger = document.getElementById('hunger');
  const uiHunFill = document.getElementById('hunFill');
  const uiFury = document.getElementById('fury');
  const uiFurFill = document.getElementById('furFill');
  const uiAtkReady = document.getElementById('atkReady');
  const uiWeaponName = document.getElementById('weaponName');
  const uiWeaponInfo = document.getElementById('weaponInfo');
  const uiStage = document.getElementById('stage');
  const uiPadHint = document.getElementById('padHint');
  const uiExitState = document.getElementById('exitState');
  const uiPelLeft = document.getElementById('pelLeft');

  const btnPower = document.getElementById('btnPower');
  const btnAttack  = document.getElementById('btnAttack');

  const modalBack = document.getElementById('modalBack');
  const btnStart = document.getElementById('btnStart');
  const btnClose = document.getElementById('btnClose');
  const btnResetRun = document.getElementById('btnResetRun');
  const menuBtn = document.getElementById('menuBtn');

  const toast = document.getElementById('toast');
  function showToast(msg){
    toast.textContent = msg;
    toast.classList.add('show');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>toast.classList.remove('show'), 900);
  }

  let paused = false;
  let last = performance.now();
  function openModal(){ modalBack.classList.add('show'); paused = true; requestAnimationFrame(resize); }
  function closeModal(){
    modalBack.classList.remove('show');
    paused = false;
    requestAnimationFrame(() => { resize(); last = performance.now(); render(0); });
  }
  btnStart.addEventListener('click', ()=>{ closeModal(); requestAnimationFrame(resize); });
  btnClose.addEventListener('click', ()=>{ closeModal(); });
  btnResetRun.addEventListener('click', ()=>{ resetRun(); closeModal(); });
  menuBtn.addEventListener('click', ()=> openModal());

  const FIRST_KEY = 'maze_hunger_seen_rules_v6';
  if(!localStorage.getItem(FIRST_KEY)){ openModal(); localStorage.setItem(FIRST_KEY, '1'); }

  const CELL = 22, MAZE_W = 25, MAZE_H = 19, WALL = 1, FLOOR = 0;
  const TURN_EPS = 0.18, CENTER_PULL = 16.0;
  const EXIT_THRESHOLD_BASE = 30, EXIT_THRESHOLD_STAGE_DECAY = 1;

  const MAX_HP = 100, MAX_FURY = 100, FURY_PER_PELLET = 4;
  const UNLOCK_BLASTER_STAGE = 3, UNLOCK_FLAME_STAGE = 6;

  const BASE_SENTINEL_HP = 5, RESPAWN_DELAY = 1.0, MIN_RESPAWN_DIST = 10, MAX_SENTINELS = 10;

  const TELEGRAPH_RANGE_TILES = 4, TELEGRAPH_TIME = 0.33, DASH_TIME = 0.60, DASH_SPEED_MULT = 1.65, DASH_COOLDOWN = 2.2, LOS_ONLY_TELEGRAPH = true;

  const PROJECTILE_SPEED = 15.0, PROJECTILE_LIFE = 0.9, PROJECTILE_HIT_INVULN = 0.15;

  const WEAPONS = {
    sword: { id:'sword', name:'SWORD', mk:'Mk1', cost:20, cooldown:0.28, action:'MELEE', range:1, dmg:1, iframesOnHit:0.55 },
    blaster:{ id:'blaster', name:'BLASTER', mk:'Mk2', cost:14, cooldown:0.22, action:'PROJECTILE', range:10, dmg:1, iframesOnHit:0.18 },
    flame: { id:'flame', name:'FLAME', mk:'Mk3', cost:34, cooldown:0.55, action:'CORRIDOR', range:8, dmg:99, iframesOnHit:0.22 }
  };

  function mulberry32(seed){ return function(){ let t = seed += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; }; }
  function key(x,y){ return (x<<16)|y; }
  function unkey(k){ return {x:(k>>>16)&0xffff, y:k&0xffff}; }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function manhattan(ax,ay,bx,by){ return Math.abs(ax-bx) + Math.abs(ay-by); }

  function genMaze(stage) {
    const seed = (Date.now() ^ (stage*99991)) >>> 0;
    const rand = mulberry32(seed);
    const w = MAZE_W, h = MAZE_H;
    const grid = Array.from({length:h}, ()=> Array(w).fill(WALL));
    function inb(x,y){ return x>=0 && y>=0 && x<w && y<h; }
    const dirs = [{dx:2,dy:0},{dx:-2,dy:0},{dx:0,dy:2},{dx:0,dy:-2}];
    grid[1][1] = FLOOR;
    const stack = [{x:1,y:1}];
    while(stack.length){
      const cur = stack[stack.length-1];
      const options = [];
      for(const d of dirs){
        const nx = cur.x+d.dx, ny=cur.y+d.dy;
        if(inb(nx,ny) && grid[ny][nx]===WALL) options.push(d);
      }
      if(!options.length){ stack.pop(); continue; }
      const d = options[(rand()*options.length)|0];
      const nx = cur.x+d.dx, ny=cur.y+d.dy;
      grid[cur.y + d.dy/2][cur.x + d.dx/2] = FLOOR;
      grid[ny][nx] = FLOOR;
      stack.push({x:nx,y:ny});
    }
    const loops = Math.min(55, 14 + stage*7);
    for(let i=0;i<loops;i++){
      const x = 1 + ((rand()*(w-2))|0);
      const y = 1 + ((rand()*(h-2))|0);
      if(grid[y][x]!==WALL) continue;
      const horiz = (grid[y][x-1]===FLOOR && grid[y][x+1]===FLOOR);
      const vert  = (grid[y-1][x]===FLOOR && grid[y+1][x]===FLOOR);
      if(horiz || vert) grid[y][x]=FLOOR;
    }
    const pellets = new Set();
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        if(grid[y][x]===FLOOR && !(x===1 && y===1)){
          const density = 0.90 - Math.min(0.18, stage*0.015);
          if(rand() < density) pellets.add(key(x,y));
        }
      }
    }
    let exit = {x:w-2,y:h-2};
    let best = -1;
    for(let tries=0;tries<260;tries++){
      const x = 1 + ((rand()*(w-2))|0);
      const y = 1 + ((rand()*(h-2))|0);
      if(grid[y][x]!==FLOOR) continue;
      const d = (x-1)*(x-1)+(y-1)*(y-1);
      if(d>best){best=d; exit={x,y};}
    }
    return { grid, pellets, exit };
  }

  const state = {
    stage: 1, score: 0, hp: MAX_HP, hunger: 0, fury: 0, multiplier: 1.0, multDecay: 0,
    powerTimer: 0, powerCooldown: 0,
    attackCD: 0, attackFlash: 0, attackEffect: 0,
    hitFlash: 0, map: null, gameOver: false, exitReady: false,
    rand: mulberry32((Date.now()>>>0) ^ 0xA5A5A5),
    weaponId: 'sword',
    p: { x:1,y:1, px:1,py:1, dir:{x:1,y:0}, want:{x:1,y:0}, speed: 7.1, invuln: 0 },
    enemies: [], respawns: [], projectiles: []
  };

  function currentWeapon(){ return WEAPONS[state.weaponId] || WEAPONS.sword; }
  function checkWeaponProgression(){
    const prev = state.weaponId;
    if(state.stage >= UNLOCK_FLAME_STAGE) state.weaponId = 'flame';
    else if(state.stage >= UNLOCK_BLASTER_STAGE) state.weaponId = 'blaster';
    else state.weaponId = 'sword';
    if(state.weaponId !== prev){
      const w = currentWeapon();
      showToast(`WEAPON UPGRADE → ${w.name} ${w.mk}`);
      state.fury = clamp(state.fury + 25, 0, MAX_FURY);
    }
  }

  function isWall(x,y){
    const g = state.map.grid;
    if(y<0||y>=g.length||x<0||x>=g[0].length) return true;
    return g[y][x]===WALL;
  }
  function canMoveTo(x,y){ return !isWall(x,y); }

  function atCellCenter(px,py){
    const cx = Math.round(px), cy = Math.round(py);
    return (Math.abs(px-cx) < 0.10 && Math.abs(py-cy) < 0.10);
  }

  function nextStepToward(sx,sy,tx,ty){
    const w = MAZE_W, h = MAZE_H;
    const start = sy*w+sx, goal = ty*w+tx;
    if(start===goal) return {x:sx,y:sy};
    const prev = new Int32Array(w*h); prev.fill(-1);
    const q = new Int32Array(w*h); let qh=0, qt=0;
    q[qt++] = start; prev[start]=start;
    while(qh<qt){
      const cur = q[qh++]; if(cur===goal) break;
      const cx = cur % w; const cy = (cur / w) | 0;
      if(cx+1<w){ const n=cur+1; if(prev[n]<0 && !isWall(cx+1,cy)){ prev[n]=cur; q[qt++]=n; } }
      if(cx-1>=0){ const n=cur-1; if(prev[n]<0 && !isWall(cx-1,cy)){ prev[n]=cur; q[qt++]=n; } }
      if(cy+1<h){ const n=cur+w; if(prev[n]<0 && !isWall(cx,cy+1)){ prev[n]=cur; q[qt++]=n; } }
      if(cy-1>=0){ const n=cur-w; if(prev[n]<0 && !isWall(cx,cy-1)){ prev[n]=cur; q[qt++]=n; } }
    }
    if(prev[goal]<0) return {x:sx,y:sy};
    let cur = goal; let p = prev[cur];
    while(p !== start && p !== cur){ cur = p; p = prev[cur]; }
    return {x:cur%w, y:(cur/w)|0};
  }

  function findFarSpawn(px,py, minDist){
    const grid = state.map.grid;
    const w = MAZE_W, h = MAZE_H;
    for(let tries=0; tries<600; tries++){
      const x = 1 + ((state.rand()*(w-2))|0);
      const y = 1 + ((state.rand()*(h-2))|0);
      if(grid[y][x]!==FLOOR) continue;
      if(manhattan(x,y,px,py) < minDist) continue;
      if(x===state.map.exit.x && y===state.map.exit.y) continue;
      return {x,y};
    }
    let best = null, bestD = -1;
    for(let y=1;y<h-1;y++)for(let x=1;x<w-1;x++){
      if(grid[y][x]!==FLOOR) continue;
      if(x===state.map.exit.x && y===state.map.exit.y) continue;
      const d = manhattan(x,y,px,py);
      if(d>bestD){ bestD=d; best={x,y}; }
    }
    return best || {x:w-2,y:h-2};
  }

  function spawnSentinelAt(x,y, level=1, speed=5.6, hpMax=BASE_SENTINEL_HP){
    if(state.enemies.length >= MAX_SENTINELS) return;
    state.enemies.push({
      x,y, px:x,py:y, dx:0,dy:0,
      baseSpeed:speed, speed,
      stepAge:0, stuckAge:0, invuln:0.25,
      level, hpMax, hp:hpMax,
      telegraph:0, dash:0, dashCD:0
    });
  }

  function spawnStageSentinels(){
    state.enemies.length = 0;
    state.respawns.length = 0;
    state.projectiles.length = 0;
    const count = Math.min(MAX_SENTINELS, 1 + Math.floor(state.stage / 2));
    const p = state.p;
    for(let i=0;i<count;i++){
      const pos = findFarSpawn(p.x,p.y, MIN_RESPAWN_DIST);
      spawnSentinelAt(pos.x,pos.y, 1, 5.6, BASE_SENTINEL_HP);
    }
  }

  function resetStage(){
    checkWeaponProgression();
    state.map = genMaze(state.stage);
    state.p.x = state.p.px = 1;
    state.p.y = state.p.py = 1;
    state.p.dir = {x:1,y:0};
    state.p.want = {x:1,y:0};
    state.p.invuln = 0;
    spawnStageSentinels();
    state.exitReady = false;
    state.powerTimer = 0;
    state.powerCooldown = 0;
    state.attackCD = 0;
    state.attackFlash = 0;
    state.attackEffect = 0;
    showToast(`Stage ${state.stage}`);
  }

  function resetRun(){
    state.stage = 1;
    state.score = 0;
    state.hp = MAX_HP;
    state.hunger = 0;
    state.fury = 0;
    state.multiplier = 1.0;
    state.multDecay = 0;
    state.gameOver = false;
    state.hitFlash = 0;
    state.weaponId = 'sword';
    resetStage();
    showToast('New Run');
  }

  resetStage();

  const input = { up:false, down:false, left:false, right:false, power:false, attack:false };
  function setWanted(dir){ state.p.want = dir; }
  function setWantedFromInput(){
    if(input.left)  setWanted({x:-1,y:0});
    if(input.right) setWanted({x: 1,y:0});
    if(input.up)    setWanted({x: 0,y:-1});
    if(input.down)  setWanted({x: 0,y: 1});
  }
  function bindPress(el, onDown, onUp){
    const down = (e)=>{ e.preventDefault(); onDown(); };
    const up = (e)=>{ e.preventDefault(); onUp(); };
    el.addEventListener('pointerdown', down);
    el.addEventListener('pointerup', up);
    el.addEventListener('pointercancel', up);
    el.addEventListener('pointerleave', up);
  }
  bindPress(btnPower, ()=>{ input.power=true; }, ()=>{ input.power=false; });
  bindPress(btnAttack, ()=>{ input.attack=true; }, ()=>{ input.attack=false; });

  window.addEventListener('keydown', (e)=>{
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' ','Shift','Escape'].includes(e.key)) e.preventDefault();
    if(e.key==='Escape'){ openModal(); return; }
    if(paused) return;
    if(e.key==='ArrowUp') input.up = true;
    if(e.key==='ArrowDown') input.down = true;
    if(e.key==='ArrowLeft') input.left = true;
    if(e.key==='ArrowRight') input.right = true;
    if(e.key===' ') input.power = true;
    if(e.key==='Shift') input.attack = true;
    setWantedFromInput();
  }, {passive:false});

  window.addEventListener('keyup', (e)=>{
    if(paused) return;
    if(e.key==='ArrowUp') input.up = false;
    if(e.key==='ArrowDown') input.down = false;
    if(e.key==='ArrowLeft') input.left = false;
    if(e.key==='ArrowRight') input.right = false;
    if(e.key===' ') input.power = false;
    if(e.key==='Shift') input.attack = false;
    setWantedFromInput();
  });

  let lastPadConnected = false;
  window.addEventListener('gamepadconnected', ()=>{
    lastPadConnected = true;
    uiPadHint.textContent = 'Gamepad connected';
    showToast('Gamepad connected');
  });
  window.addEventListener('gamepaddisconnected', ()=>{
    uiPadHint.textContent = 'Touch / Keys / Gamepad';
    showToast('Gamepad disconnected');
  });

  function pollGamepad(){
    const pads = navigator.getGamepads ? navigator.getGamepads() : [];
    const gp = pads && pads[0];
    if(!gp) return;
    if(!lastPadConnected){
      lastPadConnected = true;
      uiPadHint.textContent = 'Gamepad active';
      showToast('Gamepad active');
    }
    const dead = 0.35;
    const axX = gp.axes[0] || 0;
    const axY = gp.axes[1] || 0;
    const dUp = gp.buttons[12]?.pressed;
    const dDown = gp.buttons[13]?.pressed;
    const dLeft = gp.buttons[14]?.pressed;
    const dRight = gp.buttons[15]?.pressed;

    input.up = (axY < -dead) || !!dUp;
    input.down = (axY > dead) || !!dDown;
    input.left = (axX < -dead) || !!dLeft;
    input.right = (axX > dead) || !!dRight;

    input.power = !!gp.buttons[0]?.pressed;
    input.attack = !!gp.buttons[1]?.pressed;

    if(gp.buttons[9]?.pressed){ openModal(); }
    if(!paused) setWantedFromInput();
  }

  const joy = document.getElementById('joy');
  const knob = document.getElementById('joyKnob');
  let joyActive = false, joyPid = -1, joyCx = 0, joyCy = 0, joyRadius = 1;

  function joyReset(){
    knob.style.left = '50%';
    knob.style.top = '50%';
    input.up = input.down = input.left = input.right = false;
    setWantedFromInput();
  }
  function joyUpdateFromDelta(dx,dy){
    const mag = Math.hypot(dx,dy);
    const dead = joyRadius * 0.18;
    const cl = mag > joyRadius ? (joyRadius/mag) : 1;
    const kx = dx * cl;
    const ky = dy * cl;
    knob.style.left = `${50 + (kx/joyRadius)*34}%`;
    knob.style.top  = `${50 + (ky/joyRadius)*34}%`;
    input.up = input.down = input.left = input.right = false;
    if(mag < dead){ setWantedFromInput(); return; }
    if(Math.abs(dx) > Math.abs(dy)){ (dx>0) ? (input.right=true) : (input.left=true); }
    else { (dy>0) ? (input.down=true) : (input.up=true); }
    setWantedFromInput();
  }

  joy.addEventListener('pointerdown', (e)=>{
    e.preventDefault(); if(paused) return;
    joyActive = true; joyPid = e.pointerId; joy.setPointerCapture(joyPid);
    const r = joy.getBoundingClientRect();
    joyCx = r.left + r.width/2;
    joyCy = r.top + r.height/2;
    joyRadius = r.width * 0.34;
    joyUpdateFromDelta(e.clientX - joyCx, e.clientY - joyCy);
  });
  joy.addEventListener('pointermove', (e)=>{
    if(!joyActive || e.pointerId !== joyPid) return;
    e.preventDefault();
    joyUpdateFromDelta(e.clientX - joyCx, e.clientY - joyCy);
  });
  function joyEnd(e){ if(e && e.pointerId !== joyPid) return; joyActive=false; joyPid=-1; joyReset(); }
  joy.addEventListener('pointerup', joyEnd);
  joy.addEventListener('pointercancel', joyEnd);
  joy.addEventListener('pointerleave', joyEnd);

  function tryPower(){
    if(state.powerCooldown>0 || state.powerTimer>0) return;
    state.powerTimer = 0.85;
    state.powerCooldown = 2.2;
    showToast('POWER');
  }

  function corridorLineOfSight(ax,ay,bx,by){
    if(ax===bx){
      const step = by>ay ? 1 : -1;
      for(let y=ay+step; y!==by; y+=step) if(isWall(ax,y)) return false;
      return true;
    }
    if(ay===by){
      const step = bx>ax ? 1 : -1;
      for(let x=ax+step; x!==bx; x+=step) if(isWall(x,ay)) return false;
      return true;
    }
    return false;
  }

  function killSentinel(s){
    state.hp = MAX_HP;
    state.hitFlash = 0.25;
    const idx = state.enemies.indexOf(s);
    if(idx>=0) state.enemies.splice(idx,1);
    const p = state.p;
    const pos = findFarSpawn(p.x,p.y, MIN_RESPAWN_DIST);
    const childLevel = (s.level || 1) + 1;
    const childHpMax = Math.max(2, Math.floor((s.hpMax || BASE_SENTINEL_HP) * 0.7));
    const childSpeed = Math.min(8.0, (s.baseSpeed || 5.6) * 1.05);
    state.respawns.push({ t: RESPAWN_DELAY, x: pos.x, y: pos.y, level: childLevel, hpMax: childHpMax, speed: childSpeed });
  }

  function tryAttack(){
    const wpn = currentWeapon();
    if(state.attackCD>0) return;
    if(state.fury < wpn.cost) { state.attackCD = 0.08; return; }

    state.fury = clamp(state.fury - wpn.cost, 0, MAX_FURY);
    state.attackCD = wpn.cooldown;
    state.attackFlash = 0.16;
    state.attackEffect = 0.18;

    const p = state.p;
    const dir = (p.dir.x===0 && p.dir.y===0) ? p.want : p.dir;
    const dx = dir.x, dy = dir.y;
    if(dx===0 && dy===0){ showToast('NO DIRECTION'); return; }

    if(wpn.action === 'MELEE'){
      const tx = p.x + dx * wpn.range;
      const ty = p.y + dy * wpn.range;
      let connected = false;
      for(const s of state.enemies){
        if(s.invuln>0) continue;
        if(s.x===tx && s.y===ty){
          connected = true;
          s.hp -= wpn.dmg;
          p.invuln = Math.max(p.invuln, wpn.iframesOnHit);
          if(s.hp <= 0){ killSentinel(s); showToast('KILL → FULL HEAL (splits!)'); }
          else showToast(`SLASH! (${s.hp}/${s.hpMax})`);
          break;
        }
      }
      if(!connected) showToast('MISS');
      return;
    }

    if(wpn.action === 'PROJECTILE'){
      state.projectiles.push({ px:p.px, py:p.py, dx, dy, life: PROJECTILE_LIFE, dmg: wpn.dmg });
      showToast('PEW');
      return;
    }

    if(wpn.action === 'CORRIDOR'){
      let hits = 0;
      for(let step=1; step<=wpn.range; step++){
        const tx = p.x + dx*step;
        const ty = p.y + dy*step;
        if(isWall(tx,ty)) break;
        for(const s of state.enemies){
          if(s.invuln>0) continue;
          if(s.x===tx && s.y===ty){
            hits++;
            s.hp -= wpn.dmg;
            s.invuln = Math.max(s.invuln, 0.12);
            if(s.hp <= 0) killSentinel(s);
          }
        }
      }
      if(hits>0){
        p.invuln = Math.max(p.invuln, wpn.iframesOnHit);
        state.hp = MAX_HP;
        showToast(`BURN (${hits})`);
      } else showToast('WHOOSH');
      return;
    }
  }

  function isPerpendicular(a,b){ return (a.x !== 0 && b.y !== 0) || (a.y !== 0 && b.x !== 0); }
  function applyAutoCenter(p, dt){
    const cx = Math.round(p.px), cy = Math.round(p.py);
    if(p.dir.x !== 0){
      const dy = (cy - p.py);
      p.py += dy * (1 - Math.exp(-CENTER_PULL * dt));
    } else if(p.dir.y !== 0){
      const dx = (cx - p.px);
      p.px += dx * (1 - Math.exp(-CENTER_PULL * dt));
    }
  }
  function tryApplyBufferedTurn(p){
    const want = p.want;
    if(!want || (want.x===0 && want.y===0)) return;
    const cx = Math.round(p.px), cy = Math.round(p.py);
    const nearX = Math.abs(p.px - cx) <= TURN_EPS;
    const nearY = Math.abs(p.py - cy) <= TURN_EPS;

    if(p.dir.x===0 && p.dir.y===0){
      if(nearX && nearY && canMoveTo(cx + want.x, cy + want.y)){
        p.px = cx; p.py = cy; p.x = cx; p.y = cy;
        p.dir = {x: want.x, y: want.y};
      }
      return;
    }
    if(isPerpendicular(p.dir, want) && nearX && nearY && canMoveTo(cx + want.x, cy + want.y)){
      p.px = cx; p.py = cy; p.x = cx; p.y = cy;
      p.dir = {x: want.x, y: want.y};
      return;
    }
    if((want.x === -p.dir.x && want.y === -p.dir.y) && nearX && nearY){
      if(canMoveTo(cx + want.x, cy + want.y)){
        p.px = cx; p.py = cy; p.x = cx; p.y = cy;
        p.dir = {x: want.x, y: want.y};
      }
    }
  }

  function stepEnemy(s, dt){
    s.invuln = Math.max(0, s.invuln - dt);
    s.stepAge += dt;

    s.dashCD = Math.max(0, s.dashCD - dt);
    if(s.telegraph > 0){
      s.telegraph = Math.max(0, s.telegraph - dt);
      s.speed = s.baseSpeed * 0.75;
      // freeze dash timer while telegraphing:
      s.dash = Math.min(DASH_TIME, s.dash + dt);
    } else if(s.dash > 0){
      s.dash = Math.max(0, s.dash - dt);
      s.speed = s.baseSpeed * DASH_SPEED_MULT;
    } else {
      s.speed = s.baseSpeed;
    }

    if(atCellCenter(s.px,s.py)){
      const cx = Math.round(s.px), cy = Math.round(s.py);
      s.x = cx; s.y = cy;
      s.px = cx; s.py = cy;
    }

    const p = state.p;
    const distTiles = manhattan(s.x, s.y, p.x, p.y);
    if(s.telegraph<=0 && s.dash<=0 && s.dashCD<=0 && distTiles <= TELEGRAPH_RANGE_TILES){
      const okLOS = !LOS_ONLY_TELEGRAPH || corridorLineOfSight(s.x,s.y,p.x,p.y);
      if(okLOS){
        s.telegraph = TELEGRAPH_TIME;
        s.dash = DASH_TIME;
        s.dashCD = DASH_COOLDOWN;
      }
    }

    if(atCellCenter(s.px,s.py) || s.stepAge > 0.20){
      s.stepAge = 0;
      const step = nextStepToward(s.x,s.y, p.x,p.y);
      let dx = clamp(step.x - s.x, -1, 1);
      let dy = clamp(step.y - s.y, -1, 1);

      if((dx===0 && dy===0) || !canMoveTo(s.x+dx, s.y+dy)){
        const opts = [];
        if(canMoveTo(s.x+1,s.y)) opts.push({dx:1,dy:0});
        if(canMoveTo(s.x-1,s.y)) opts.push({dx:-1,dy:0});
        if(canMoveTo(s.x,s.y+1)) opts.push({dx:0,dy:1});
        if(canMoveTo(s.x,s.y-1)) opts.push({dx:0,dy:-1});
        if(opts.length){
          const pick = opts[(state.rand()*opts.length)|0];
          dx = pick.dx; dy = pick.dy;
        }
      }

      if(dx===0 && dy===0) s.stuckAge += dt;
      else s.stuckAge = 0;

      if(s.stuckAge > 0.5){
        const opts = [];
        if(canMoveTo(s.x+1,s.y)) opts.push({dx:1,dy:0});
        if(canMoveTo(s.x-1,s.y)) opts.push({dx:-1,dy:0});
        if(canMoveTo(s.x,s.y+1)) opts.push({dx:0,dy:1});
        if(canMoveTo(s.x,s.y-1)) opts.push({dx:0,dy:-1});
        if(opts.length){
          const pick = opts[(state.rand()*opts.length)|0];
          dx = pick.dx; dy = pick.dy;
          s.stuckAge = 0;
        }
      }
      s.dx = dx; s.dy = dy;
    }

    if(s.dx || s.dy){
      s.px += s.dx * s.speed * dt;
      s.py += s.dy * s.speed * dt;
      const cx = Math.round(s.px), cy = Math.round(s.py);
      if(!canMoveTo(cx,cy)){
        s.px = s.x; s.py = s.y;
        s.dx = 0; s.dy = 0;
      }
    }
  }

  function stepProjectiles(dt){
    for(let i=state.projectiles.length-1;i>=0;i--){
      const pr = state.projectiles[i];
      pr.life -= dt;
      if(pr.life <= 0){ state.projectiles.splice(i,1); continue; }
      pr.px += pr.dx * PROJECTILE_SPEED * dt;
      pr.py += pr.dy * PROJECTILE_SPEED * dt;
      const cx = Math.round(pr.px), cy = Math.round(pr.py);
      if(isWall(cx,cy)){ state.projectiles.splice(i,1); continue; }

      let hit = null;
      for(const s of state.enemies){
        if(s.invuln>0) continue;
        if(Math.hypot(pr.px - s.px, pr.py - s.py) < 0.33){ hit = s; break; }
      }
      if(hit){
        hit.hp -= pr.dmg;
        hit.invuln = Math.max(hit.invuln, PROJECTILE_HIT_INVULN);
        const wpn = currentWeapon();
        state.p.invuln = Math.max(state.p.invuln, wpn.iframesOnHit);
        if(hit.hp <= 0){ killSentinel(hit); showToast('KILL → FULL HEAL'); }
        else showToast('HIT');
        state.projectiles.splice(i,1);
      }
    }
  }

  canvas.addEventListener('pointerdown', ()=>{
    if(state.gameOver){ resetRun(); requestAnimationFrame(()=>{ resize(); render(0); }); }
  });

  function tick(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    pollGamepad();
    if(paused || state.gameOver){ render(dt); return; }

    const wpn = currentWeapon();

    state.p.invuln = Math.max(0, state.p.invuln - dt);
    state.powerTimer = Math.max(0, state.powerTimer - dt);
    state.powerCooldown = Math.max(0, state.powerCooldown - dt);
    state.attackCD = Math.max(0, state.attackCD - dt);
    state.attackFlash = Math.max(0, state.attackFlash - dt);
    state.attackEffect = Math.max(0, state.attackEffect - dt);
    state.hitFlash = Math.max(0, state.hitFlash - dt*1.8);

    if(input.power) tryPower();
    if(input.attack) tryAttack();

    const movingInput = (input.up||input.down||input.left||input.right) || (state.p.dir.x!==0||state.p.dir.y!==0);
    state.hunger += dt * (movingInput ? 5.0 : 8.5);
    state.hunger = clamp(state.hunger, 0, 100);
    if(state.hunger >= 100){ state.hp -= dt * 11.0; state.hitFlash = Math.max(state.hitFlash, 0.25); }

    if(movingInput){
      state.multiplier += dt * 0.18;
      state.multiplier = clamp(state.multiplier, 1.0, 6.0);
      state.multDecay = 0;
    } else {
      state.multDecay += dt;
      if(state.multDecay > 0.35){
        state.multiplier -= dt * 0.42;
        state.multiplier = clamp(state.multiplier, 1.0, 6.0);
      }
    }

    const p = state.p;
    applyAutoCenter(p, dt);
    tryApplyBufferedTurn(p);

    if(atCellCenter(p.px, p.py)){
      const cx = Math.round(p.px), cy = Math.round(p.py);
      p.x = cx; p.y = cy; p.px = cx; p.py = cy;

      if(!canMoveTo(cx+p.dir.x, cy+p.dir.y)) p.dir = {x:0,y:0};

      const k = key(p.x,p.y);
      if(state.map.pellets.has(k)){
        state.map.pellets.delete(k);
        state.score += Math.round(10 * state.multiplier);
        state.hunger = clamp(state.hunger - 14, 0, 100);
        state.fury = clamp(state.fury + FURY_PER_PELLET, 0, MAX_FURY);
        if(state.hunger > 70) state.hp = clamp(state.hp + 0.6, 0, MAX_HP);
      }
    }

    const baseSpeed = p.speed + (state.hunger/100)*1.05;
    const spd = baseSpeed * (state.powerTimer>0 ? 1.65 : 1.0);

    if(p.dir.x!==0 || p.dir.y!==0){
      const nx = p.px + p.dir.x * spd * dt;
      const ny = p.py + p.dir.y * spd * dt;
      const cx = Math.round(p.px), cy = Math.round(p.py);

      if(p.dir.x!==0){
        const nextCellX = p.dir.x>0 ? cx+1 : cx-1;
        const boundary = cx + (p.dir.x>0 ? 0.5 : -0.5);
        if(!canMoveTo(nextCellX, cy) && ((p.dir.x>0 && nx>boundary) || (p.dir.x<0 && nx<boundary))){
          p.px = cx; p.py = cy; p.dir = {x:0,y:0};
        } else { p.px = nx; p.py = ny; }
      } else {
        const nextCellY = p.dir.y>0 ? cy+1 : cy-1;
        const boundary = cy + (p.dir.y>0 ? 0.5 : -0.5);
        if(!canMoveTo(cx, nextCellY) && ((p.dir.y>0 && ny>boundary) || (p.dir.y<0 && ny<boundary))){
          p.px = cx; p.py = cy; p.dir = {x:0,y:0};
        } else { p.px = nx; p.py = ny; }
      }
    }

    const pelletsLeft = state.map.pellets.size;
    const threshold = Math.max(0, EXIT_THRESHOLD_BASE - (state.stage*EXIT_THRESHOLD_STAGE_DECAY));
    state.exitReady = pelletsLeft <= threshold;

    const exit = state.map.exit;
    if(p.x===exit.x && p.y===exit.y && state.exitReady){
      state.stage++;
      state.score += Math.round(75 * state.multiplier);
      resetStage();
      render(dt);
      return;
    }

    for(const s of state.enemies) stepEnemy(s, dt);
    stepProjectiles(dt);

    for(const s of state.enemies){
      if(p.invuln>0) break;
      if(Math.hypot((p.px - s.px), (p.py - s.py)) < 0.40){
        state.hp -= 19;
        p.invuln = 0.85;
        state.multiplier = 1.0;
        state.hitFlash = 1.0;
        showToast('HIT!');
        break;
      }
    }

    for(let i=state.respawns.length-1; i>=0; i--){
      const r = state.respawns[i];
      r.t -= dt;
      if(r.t <= 0){
        state.respawns.splice(i,1);
        const ppos1 = findFarSpawn(p.x,p.y, MIN_RESPAWN_DIST);
        spawnSentinelAt(ppos1.x, ppos1.y, r.level, r.speed, r.hpMax);
        const ppos2 = findFarSpawn(p.x,p.y, MIN_RESPAWN_DIST);
        spawnSentinelAt(ppos2.x, ppos2.y, r.level, r.speed, r.hpMax);
      }
    }

    state.hp = clamp(state.hp, 0, MAX_HP);
    if(state.hp<=0){ state.gameOver = true; showToast('SYSTEM FAILURE — Tap to restart'); }

    uiScore.textContent = String(state.score);
    uiMult.textContent = `×${state.multiplier.toFixed(1)} ${movingInput ? 'rolling' : 'decay'}`;
    uiHP.textContent = String(Math.round(state.hp));
    uiHunger.textContent = String(Math.round(state.hunger));
    uiFury.textContent = String(Math.round(state.fury));
    uiStage.textContent = String(state.stage);

    uiHPFill.style.width = `${state.hp}%`;
    uiHPFill.classList.toggle('danger', state.hp<35);
    uiHPFill.classList.toggle('good', state.hp>=35);
    uiHunFill.style.width = `${state.hunger}%`;
    uiFurFill.style.width = `${(state.fury/MAX_FURY)*100}%`;

    uiWeaponName.textContent = wpn.name;
    uiWeaponInfo.textContent = `${wpn.mk} • cost ${wpn.cost} • ${wpn.action==='MELEE' ? 'range '+wpn.range : (wpn.action==='PROJECTILE' ? 'ranged' : 'sweep')}`;

    const need = Math.max(0, wpn.cost - state.fury);
    if(state.attackCD>0) uiAtkReady.textContent = `ATTACK: cooling (${state.attackCD.toFixed(2)}s)`;
    else if(need>0) uiAtkReady.textContent = `ATTACK: need ${need} Fury`;
    else uiAtkReady.textContent = `ATTACK: READY`;

    uiExitState.textContent = state.exitReady ? 'READY' : 'LOCKED';
    uiExitState.style.color = state.exitReady ? 'var(--good)' : 'var(--ink)';
    uiPelLeft.textContent = `pellets: ${pelletsLeft} (need ≤ ${threshold})`;

    btnPower.classList.toggle('active', state.powerTimer>0);
    btnPower.classList.toggle('disabled', state.powerCooldown>0 && state.powerTimer<=0);

    const attackReady = (state.attackCD<=0 && state.fury >= wpn.cost);
    btnAttack.classList.toggle('active', state.attackFlash>0);
    btnAttack.classList.toggle('attack-ready', attackReady);
    btnAttack.classList.toggle('disabled', state.attackCD>0 || !attackReady);
    if(state.attackCD>0) btnAttack.textContent = 'ATTACK (CD)';
    else if(!attackReady) btnAttack.textContent = `ATTACK (NEED ${need})`;
    else btnAttack.textContent = 'ATTACK (READY)';

    render(dt);
  }

  function render(dt){
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;

    const mazePxW = MAZE_W * CELL;
    const mazePxH = MAZE_H * CELL;
    const scale = Math.min((w-18)/mazePxW, (h-18)/mazePxH);
    const drawW = mazePxW * scale;
    const drawH = mazePxH * scale;
    const ox = (w - drawW)/2;
    const oy = (h - drawH)/2;

    ctx.fillStyle = '#04040e';
    ctx.fillRect(0,0,w,h);

    if(state.hitFlash>0){
      ctx.fillStyle = `rgba(255,90,122,${0.18*state.hitFlash})`;
      ctx.fillRect(0,0,w,h);
    }

    ctx.save();
    ctx.translate(ox, oy);
    ctx.scale(scale, scale);

    ctx.shadowBlur = 10;
    ctx.shadowColor = 'rgba(125,249,255,0.35)';
    for(let y=0;y<MAZE_H;y++){
      for(let x=0;x<MAZE_W;x++){
        ctx.fillStyle = (state.map.grid[y][x]===WALL) ? 'rgba(125,249,255,0.11)' : 'rgba(255,255,255,0.02)';
        ctx.fillRect(x*CELL, y*CELL, CELL, CELL);
      }
    }

    ctx.shadowBlur = 8;
    ctx.shadowColor = 'rgba(232,233,255,0.25)';
    for(const k of state.map.pellets){
      const {x,y} = unkey(k);
      const cx = x*CELL + CELL*0.5, cy = y*CELL + CELL*0.5;
      ctx.beginPath(); ctx.arc(cx,cy,3.2,0,Math.PI*2);
      ctx.fillStyle = 'rgba(232,233,255,0.70)';
      ctx.fill();
    }

    const ex = state.map.exit.x*CELL, ey = state.map.exit.y*CELL;
    ctx.shadowBlur = 16;
    ctx.shadowColor = state.exitReady ? 'rgba(124,255,154,0.55)' : 'rgba(255,211,110,0.22)';
    ctx.fillStyle = state.exitReady ? 'rgba(124,255,154,0.14)' : 'rgba(255,211,110,0.06)';
    ctx.fillRect(ex+2, ey+2, CELL-4, CELL-4);
    ctx.strokeStyle = state.exitReady ? 'rgba(124,255,154,0.75)' : 'rgba(255,211,110,0.35)';
    ctx.lineWidth = 2;
    ctx.strokeRect(ex+4, ey+4, CELL-8, CELL-8);

    for(const pr of state.projectiles){
      const cx = pr.px*CELL + CELL*0.5, cy = pr.py*CELL + CELL*0.5;
      ctx.shadowBlur = 18;
      ctx.shadowColor = 'rgba(255,211,110,0.65)';
      ctx.fillStyle = 'rgba(255,211,110,0.90)';
      ctx.beginPath(); ctx.arc(cx,cy,4.5,0,Math.PI*2); ctx.fill();
    }

    for(const s of state.enemies){
      const ecx = s.px*CELL + CELL*0.5, ecy = s.py*CELL + CELL*0.5;

      if(s.telegraph > 0){
        const t = s.telegraph / TELEGRAPH_TIME;
        ctx.shadowBlur = 22;
        ctx.shadowColor = 'rgba(255,90,122,0.85)';
        ctx.strokeStyle = `rgba(255,90,122,${0.25 + 0.55*(1-t)})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(ecx, ecy, CELL*0.62 + (1-t)*6, 0, Math.PI*2);
        ctx.stroke();

        ctx.shadowBlur = 0;
        ctx.fillStyle = 'rgba(255,211,110,0.95)';
        ctx.font = 'bold 16px system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('!', ecx, ecy - CELL*0.62);
      }

      ctx.shadowBlur = 14;
      ctx.shadowColor = (s.dash>0) ? 'rgba(255,90,122,0.85)' : 'rgba(255,90,122,0.55)';
      ctx.beginPath();
      ctx.arc(ecx, ecy, CELL*0.34, 0, Math.PI*2);
      ctx.fillStyle = `rgba(255,90,122,${s.dash>0 ? 0.95 : 0.83})`;
      ctx.fill();

      const frac = s.hpMax>0 ? (s.hp/s.hpMax) : 0;
      ctx.shadowBlur = 0;
      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      ctx.fillRect(ecx - CELL*0.36, ecy - CELL*0.55, CELL*0.72, 4);
      ctx.fillStyle = 'rgba(255,211,110,0.85)';
      ctx.fillRect(ecx - CELL*0.36, ecy - CELL*0.55, CELL*0.72*frac, 4);
    }

    const p = state.p;
    const pcx = p.px*CELL + CELL*0.5, pcy = p.py*CELL + CELL*0.5;
    const mouth = 0.55 + 0.25*Math.sin(performance.now()/85);
    const ang = Math.atan2(p.dir.y, p.dir.x);

    ctx.shadowBlur = 16;
    if(p.invuln > 0 && state.attackEffect > 0){
      ctx.shadowBlur = 28;
      ctx.shadowColor = 'rgba(255,211,110,0.90)';
    } else {
      ctx.shadowColor = (p.invuln>0) ? 'rgba(125,249,255,0.6)' : 'rgba(232,233,255,0.35)';
    }

    ctx.beginPath();
    ctx.moveTo(pcx, pcy);
    ctx.arc(pcx, pcy, CELL*0.36, ang+mouth, ang+(Math.PI*2-mouth));
    ctx.closePath();
    ctx.fillStyle = (p.invuln>0) ? 'rgba(125,249,255,0.95)' : 'rgba(232,233,255,0.90)';
    ctx.fill();

    if(state.powerTimer>0){
      ctx.shadowBlur = 22;
      ctx.shadowColor = 'rgba(125,249,255,0.6)';
      ctx.beginPath();
      ctx.arc(pcx, pcy, CELL*0.58, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(125,249,255,0.65)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    const wpn = currentWeapon();
    if(state.attackFlash>0){
      const dir = (p.dir.x===0 && p.dir.y===0) ? p.want : p.dir;
      const tx = (p.x + dir.x)*CELL + CELL*0.5;
      const ty = (p.y + dir.y)*CELL + CELL*0.5;

      if(wpn.action === 'MELEE'){
        ctx.shadowBlur = 18;
        ctx.shadowColor = 'rgba(255,211,110,0.65)';
        ctx.strokeStyle = 'rgba(255,211,110,0.85)';
        ctx.lineWidth = 4;
        ctx.beginPath(); ctx.moveTo(pcx,pcy); ctx.lineTo(tx,ty); ctx.stroke();
      } else if(wpn.action === 'CORRIDOR'){
        ctx.shadowBlur = 20;
        ctx.shadowColor = 'rgba(255,211,110,0.65)';
        ctx.strokeStyle = 'rgba(255,211,110,0.70)';
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(pcx, pcy);
        let endx = pcx, endy = pcy;
        for(let step=1; step<=wpn.range; step++){
          const gx = p.x + dir.x*step, gy = p.y + dir.y*step;
          if(isWall(gx,gy)) break;
          endx = gx*CELL + CELL*0.5;
          endy = gy*CELL + CELL*0.5;
        }
        ctx.lineTo(endx, endy);
        ctx.stroke();
      }
    }

    if(paused){
      ctx.shadowBlur = 0;
      ctx.fillStyle = 'rgba(0,0,0,0.62)';
      ctx.fillRect(0,0,MAZE_W*CELL,MAZE_H*CELL);
      ctx.fillStyle = 'rgba(232,233,255,0.92)';
      ctx.font = 'bold 22px system-ui';
      ctx.textAlign='center';
      ctx.fillText('PAUSED', (MAZE_W*CELL)/2, (MAZE_H*CELL)/2);
      ctx.font = '13px system-ui';
      ctx.fillStyle = 'rgba(232,233,255,0.68)';
      ctx.fillText('Close the menu to resume', (MAZE_W*CELL)/2, (MAZE_H*CELL)/2 + 18);
    }

    if(state.gameOver){
      ctx.shadowBlur = 0;
      ctx.fillStyle = 'rgba(0,0,0,0.70)';
      ctx.fillRect(0,0,MAZE_W*CELL,MAZE_H*CELL);
      ctx.fillStyle = 'rgba(232,233,255,0.96)';
      ctx.font = 'bold 26px system-ui';
      ctx.textAlign='center';
      ctx.fillText('SYSTEM FAILURE', (MAZE_W*CELL)/2, (MAZE_H*CELL)/2 - 12);
      ctx.font = '14px system-ui';
      ctx.fillStyle = 'rgba(232,233,255,0.75)';
      ctx.fillText('Tap to restart', (MAZE_W*CELL)/2, (MAZE_H*CELL)/2 + 18);
    }

    ctx.restore();
  }

  function loop(now){
    try{ tick(now); }
    catch(e){ showError(`RUNTIME CRASH:\n${e.message}\n\n${e.stack||''}`); return; }
    requestAnimationFrame(loop);
  }

  render(0);
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
